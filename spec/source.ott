metavar typvar, a {{ tex a }}, b {{tex b}}, L ::=
metavar kindvar, X, Xy {{ tex X}}, Xlist {{ tex \overbar{X} }}, Xlistwithi {{ tex \overbar{X_i} }}, Xa {{ tex \widehat{\alpha} }}, Xya {{ tex \widehat{\alpha} }}, Xb {{ tex \widehat{\beta} }} ::=

metavar expvar, x, y, f, g, m, nn {{ tex n }}, c, xs, fix {{ tex \mathsf{fix} }}, len, l ::=

metavar  lit, ii {{tex {i} }} ::=
metavar tconstrvar , T {{ tex T }} , Ty {{ tex T }}, Tt {{ tex \widetilde{ \mathcal{T} } }} ::=
indexvar index, i, j, n, m, l, sj {{ tex j + 1 }}, ssi {{ tex i + 1 }} , sn {{ tex n + 1 }}::=
metavar dconstrvar , D {{ tex D }} ::=

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL TYPE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

% Types

mode :: 'mode_' ::=
  | =>       ::  :: infer {{ tex \Rightarrow }}
  | <=       ::  :: check {{ tex \Leftarrow }}

prmode, pm {{ tex \otimes }} :: 'prmode_'  ::=
  | +       ::  :: postive  {{ tex \texttt{+} }}
  | -       ::  :: negative {{ tex \texttt{-} }}
  | pminus  ::  :: pminus   {{ tex \texttt{-} }}
  | - pm    ::  :: negate   {{ tex \texttt{-} [[pm]] }}
  | ( pm )  ::  :: paren

varset, avs  :: 'varset_' ::=
  | a                        ::  :: a
  | x                        ::  :: x {{ tex x }}
  | avs1 , .. , avs2         ::  :: append
  | fv ( dd )                ::  :: fv_dd
  | fv ( GG )                ::  :: fv_gg
  | fv ( A )                 ::  :: fv_A
  | fv ( aA )                ::  :: fv_aA
  | fv ( ef )                ::  :: fv_ef
  | avs set                  ::  :: a_set {{ tex \overbar{[[avs]]} }}
  | avs1 - avs2              ::  :: minus {{ tex [[avs1]] - [[avs2]] }}

kvarset, kvs {{ tex \phi }} , kvsy {{tex \phi }},  ckvs {{ tex \phi^{\mathsf{c} } }} , ckvsy  {{ tex \phi^{\mathsf{c} } }}, ikvs {{ tex \phi^{\star} }}, iikvs {{ tex \phi^{\star}_{i} }}, xkvs {{ tex \widehat{\phi}^{\star} }} , xckvs{{ tex \widehat{\phi}^{\mathsf{c} } }} :: 'kvs_' ::=
  | X         ::  :: vars
  | Xa = k    ::  :: solved_kuvars
  | X : K     ::  :: kvars
  | Xa : K = k    ::  :: solved_typed_kuvars
  | a         ::  :: tvars
  | a : K     ::  :: ktvar
  | fkv ( K )             ::  :: fkv_kind
    {{ tex [[fkv]]([[K]]) }}
  | fkv ( DD )            ::  :: fkv_tctx
    {{ tex [[fkv]]([[DD]]) }}
  | fkb ( K )             ::  :: fkb_tctx
    {{ tex [[fkb]]([[K]]) }}
  | kvs1 - kvs2           ::  :: minus {{ tex [[kvs1]] \backslash_{[[kvs2]]} }}
  | kvs1 + kvs2           ::  :: set_plus  {{ tex [[kvs1]]~\cup~[[kvs2]] }}
  | kvs1 , ... , kvs2     ::  :: append_multiple
  | empty                 ::  :: empty
  | ( kvs )               ::  :: paren
  | LS ( K )              ::  :: LexicalSort
    {{ tex [[LS]]([[K]]) }}
  | SS ( kvs )              ::  :: ScopedSort
    {{ tex [[SS]]([[kvs]]) }}
  | unsolved ( K )        ::  :: unsolved
    {{ tex [[unsolved]]([[K]]) }}
  | unsolved ( DD )        ::  :: unsolved_ctx
    {{ tex [[unsolved]]([[DD]]) }}
  | Lunsolved ( DD , K )        ::  :: Lunsolved
  | Lunsolved ( DD , </ Ki // i /> )        ::  :: Lunsolved_mult
  | [ DD ] kvs             ::  :: apply_ctx
  | hat ckvs             ::   :: tilde {{ tex \widetilde{[[ckvs]]} }}
  | fresh ( ckvs )         ::  :: fresh
  | kvs [ </ kvsl |-> kvsl' // l /> ]     ::  :: subst_kvs
  | kvs1 ^ kvs2      ::  :: kvs_inter {{ tex [[kvs1]]~\cap~[[kvs2]] }}
  | dom ( DD )       ::   :: dom
    {{ tex [[dom]]([[DD]]) }}
  | var ( K )         ::   :: var
    {{ tex [[var]]([[K]]) }}

dtyp, A {{tex \sigma}}, B {{tex \sigma_2}}, C {{tex \sigma_3}}, K {{tex K}}, eA {{tex \mu}}, eK {{tex \eta}}  :: 'dtyp_' ::=
  | X              ::  :: vars
  | int            ::   :: int
  | star           ::   :: star
  | nat            ::   :: nat
  | natu           ::   :: natu {{ tex \mathsf{Nat}_\unknown }}
  | float          ::   :: float
  | bool           ::   :: bool
  | boolu          ::   :: boolu {{ tex \mathsf{Bool}_\unknown }}
  | top            ::   :: top
  | a              ::   :: tvar
  | A -> B         ::   :: arrow
  | \/ varset . A  ::   :: all
  | \/ varset . t  ::   :: all_mono
  | mu a . A       ::   :: mu {{ tex \mu [[a]] [[.]] [[A]] }}
  | unknown        ::   :: unknown
  | question       ::   :: question
  | static         ::   :: static
  | gradual        ::   :: gradual
  | List A         ::   :: list
  | Listu A        ::   :: listu
  | A [ </  Ai ~> Bi // i /> ]  :: M :: subst
  | [ OO ] aA      :: S :: ctx_subst
  | [ OO ] A       :: S :: ctx_subst2
  | ( A )          :: S :: parens
  | S ( A )        :: S :: subst2
  | ss -> A        ::   :: sctx_type
  | ( A , B )      ::   :: pair
  | [ l1 : A1 , .. , ln : An  ]  ::   :: record
  | erase [ A ]    ::  :: erasetp {{ tex \lceil{[[A]]}\rceil }}
  | \/ kvs  . A                 ::  :: kind_forall
  | T                      ::  :: tcon
  | A </ ti // i />        ::  :: apps
  | </ Ki // i /> ---> K       ::  :: arrowl
  | \/ [ kvs ] . A              ::  :: forall_kvs {{ tex [[\/]] [[kvs]]. ~ [[A]] }}
  | \/i [ kvs ] . A             ::  :: forall_kvsi {{ tex \forall \{ [[kvs]] \}. [[A]] }}
  | \/s [ kvs ] . A             ::  :: forall_kvss {{ tex \forall [[kvs]]. ~ [[A]] }}
  | \/r [ kvs ] . A             ::  :: forall_kvsr {{ tex \forall [[kvs]] \arrow ~ [[A]] }}
  | A1 @ A2                ::  :: visible_app {{ tex [[A1]]~@[[A2]] }}
  | A1 @@ A2               ::  :: visible_app' {{ tex [[A1]]~@@[[A2]] }} % ESCAPING @ FOR lhs2tex
  | K @ [ kvs ]            ::  :: tcon_at_kvs {{ tex [[K]]~ @[[kvs]] }}
  | K @@ [ kvs ]           ::  :: tcon_at_kvs' {{ tex [[K]]~ @@[[kvs]] }}
  | K @ [ kinds ]          ::  :: tcon_at_kinds {{ tex [[K]]~ @[[kinds]] }}
  | K @@ [ kinds ]         ::  :: tcon_at_kinds' {{ tex [[K]]~ @@[[kinds]] }}
  | \/ kvs -> A                 ::  :: forall_required
  | A [ a |-> t ]           ::  :: subst_poly
  | A [ X |-> k ]           ::  :: subst_poly_k
  | A [ T |-> A1 ]          ::  :: subst_tcon
  | A [ </ kvsl |-> kvsl' // l /> ]     ::  :: subst_kvs
  | A [ </ ai |-> ti // i /> ]         ::  :: subst_mult
  | A [ </ Xi |-> ki // i /> ]         ::  :: subst_k_mult
  | A [ </ Ti |-> ki // i /> ]         ::  :: subst_t_mult
  | P                      ::  :: type_par {{ tex P }}
  | \bot                   ::  :: any
  | tsub ( K )             ::  :: tsubst

kinds :: 'kinds_' ::=
  | </ Ki // i />       :: :: ks

% Mono Types

dtyp_mono, t {{ tex \tau }}, s {{ tex \tau }}, k {{tex \kappa}}, et {{tex \rho}}, ek {{tex \omega }} :: 'dtyp_mono_' ::=
  | int       ::   :: int
  | nat            ::   :: nat
  | star      ::   :: star
  | a         ::   :: tvar
  | X              ::  :: vars
  | t -> s    ::   :: arrow
  | [ DD ] t  ::   :: apply
  | T                      ::  :: tcon
  | ( t )                  ::  :: paren
  | static    ::   :: static
  | gradual   ::   :: gradual
  | t [ </  ti ~>  si // i /> ]  :: M :: subst
  | t </ ti // i />        ::  :: apps
  | </ ti // i /> ---> t    ::  :: arrowl
  | t1 @ t2                ::  :: visible_app {{ tex [[t1]]~@[[t2]] }}
  | t1 @@ t2               ::  :: visible_app' {{ tex [[t1]]~@@[[t2]] }}
  | t @ [ kvs ]            ::  :: tcon_at_kvs {{ tex [[t]]~ @[[kvs]] }}
  | t @@ [ kvs ]           ::  :: tcon_at_kvs' {{ tex [[t]]~ @@[[kvs]] }}
  | t1 [ a |-> t2 ]         ::  :: subst_kk
  | t1 [ X |-> k2 ]         ::  :: subst_k
  | t1 [ </ ai |-> ti // i /> ]         ::  :: subst_mult
  | t1 [ </ Xi |-> ki // i /> ]         ::  :: subst_k_mult

% Castable Mono Types

dtyp_mono_cast, tc {{ tex t }} :: 'dtyp_mono_cast_' ::=
  | int        :: :: int
  | nat            ::   :: nat
  | X              ::  :: vars
  | a          :: :: tvar
  | tc1 -> tc2 :: :: arrow
  | gradual    :: :: gradual

% Castable Types

dtyp_castable, gc  {{ tex \mathbb{C} }}  :: 'dtyp_castable_' ::=
  | int        :: :: int
  | nat            ::   :: nat
  | X              ::  :: vars
  | a          :: :: tvar
  | gc1 -> gc2 :: :: arrow
  | \/ varset . gc  :: :: all
  | unknown    :: :: unknown
  | gradual    :: :: gradual


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO TYPE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Existential variable

evar {{ tex \widehat{\alpha} }}, evara {{tex \widehat{\alpha} }}, evarb {{ tex \widehat{\beta} }} :: 'evar_' ::=
  | sa :: :: evar {{ tex \widehat{\alpha}_{S} }}
  | ga :: :: gevar {{ tex \widehat{\alpha}_{G} }}
  | sb :: :: evarb {{ tex \widehat{\beta}_{S} }}
  | gb :: :: gevarb {{ tex \widehat{\beta}_{G} }}
  | Xa :: :: xa


% marker
ma :: 'ma_' ::=
  | mevar :: :: mevar   {{ tex \blacktriangleright_{ \widehat{\alpha} } }}
  | mevarb :: :: mevarb   {{ tex \blacktriangleright_{ \widehat{\beta} } }}
  | msa :: :: msa  {{ tex \blacktriangleright_{ \widehat{a}_S } }}
  | msb :: :: msb  {{ tex \blacktriangleright_{ \widehat{b}_S } }}


% Types

atyp, aA {{ tex \sigma }}, aB, aC  :: 'atyp_' ::=
  | int            ::   :: int
  | star           ::   :: star
  | a              ::   :: tvar
  | evar           ::   :: evar
  | aA1 -> aA2     ::   :: arrow
  | \/ a . aA      ::   :: all
  | unknown        ::   :: unknown
  | static         ::   :: static
  | gradual        ::   :: gradual
  | aA [ a ~> at ] :: M :: subst
  | [ GG ] aA      :: S :: ctx_subst
  | ( aA )         :: S :: parens
  | Pi a : aA1 . aA2 ::   :: pi

% Static Types

atyp_static, aT {{ tex T }} :: 'atyp_static_' ::=
  | int        ::   :: int
  | star           ::   :: star
  | a          ::   :: tvar
  | evar       ::   :: evar
  | aT1 -> aT2 ::   :: arrow
  | \/ a . aT  ::   :: all
  | static     ::   :: static
  | gradual    ::   :: gradual
  | [ GG ] aA  :: S :: ctx_subst
  | Pi a : aA1 . aA2 ::   :: pi

% Mono Types

atyp_mono, at {{ tex \tau }}, as {{ tex \sigma }} :: 'atyp_mono_' ::=
  | int       ::   :: int
  | star      ::   :: star
  | a         ::   :: tvar
  | evar      ::   :: evar
  | at -> as  ::   :: arrow
  | static    ::   :: static
  | gradual   ::   :: gradual
  | [ GG ] aA :: S :: ctx_subst
  | Pi a : aA1 . aA2 ::   :: pi

% Castable Mono Types

atyp_mono_cast, atc {{ tex t }} :: 'atyp_mono_cast_' ::=
  | int          :: :: int
  | a            :: :: tvar
  | evar         :: :: evar
  | atc1 -> atc2 :: :: arrow
  | gradual      :: :: gradual

% Castable Types

atyp_castable, agc  {{ tex \mathbb{C} }}  :: 'atyp_castable_' ::=
  | int          :: :: int
  | a            :: :: tvar
  | evar         :: :: evar
  | agc1 -> agc2 :: :: arrow
  | \/ a . agc   :: :: all
  | unknown      :: :: unknown
  | gradual      :: :: gradual

% Static Castable Types
atyp_scastable, asc {{ tex \mathbb{S} }} :: 'atyp_scastable_' ::=
  | int          :: :: int
  | a            :: :: tvar
  | evar         :: :: evar
  | asc1 -> asc2 :: :: arrow
  | \/ a . asc   :: :: all
  | gradual      :: :: gradual




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL EXPR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

dexp, e :: 'dtrm_' ::=
  | 1                ::   :: one
  | 2                ::   :: two
  | 3                ::   :: three
  | x                ::   :: var
  | id               ::   :: id {{ tex \mathsf{id} }}
  | n                ::   :: lit
  | cons             ::   :: cons
  | consu             ::   :: consu
  | nil              ::   :: nilu
  | nilu              ::   :: nil
  | zerou            :: :: zero {{ tex \mathsf{zero}_\unknown }}
  | succu            :: :: succu {{ tex \mathsf{succ}_\unknown }}
  | trueu            :: :: trueu {{ tex \mathsf{true}_\unknown }}
  | true             :: :: true  {{ tex \mathsf{true} }}
  | fold [ A ]       ::   :: fold  {{ tex [[fold]]_{[[A]]} }}
  | unfold [ A ]       ::   :: unfold  {{ tex [[unfold]]_{[[A]]} }}
  | \ x . e          ::   :: abs
  | \ x : A . e      ::   :: absan
  | e1 e2            ::   :: app {{ tex [[e1]]~[[e2]] }}
  | let x = e1 in e2 ::   :: let
  | let x : A = e1 in e2 ::   :: letann
  | ( e )            :: S :: paren
  | e : A            :: S :: anno
  | ( e1 , e2 )      ::   :: pair
  | 'a'              ::   :: a
  | fst              ::   :: fst
  | snd              ::   :: snd
  | e1 + e2          ::   :: plus
  | | e |            ::   :: erase


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO EXPR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

aexp, ae {{ tex e }} :: 'atrm_' ::=
  | x                  ::   :: var
  | n                  ::   :: lit
  | \ x . ae           ::   :: abs
  | \ x : aA . ae      ::   :: absan
  | ae1 ae2            ::   :: app {{ tex [[ae1]]~[[ae2]] }}
  | ae : aA            ::   :: anno
  | let x = ae1 in ae2 ::   :: let
  | ( ae )             :: S :: paren
  | | ae |             ::   :: erase



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL CONTEXT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tctx, EE  {{tex \Sigma}} :: 'tctx_' ::=
  | empty             ::  :: empty
  | a : K             ::  :: tvar
  | X                 ::  :: kvar
  | Xa = k            ::  :: kuvar_solved
  | Ti : Ki           ::  :: tconstr_s
  | ( EE )            ::  :: paren
  | EE1 , .... , EEi  ::  :: append_multiple
  | EE [ Xa ]         ::  :: contains
  | EE [ Xa = k ]     ::  :: contains_solve
  | [ OO ] DD         ::  :: context_apply
  | Q ( K )           ::  :: quantifier
    {{ tex [[Q]]([[K]]) }}
  | Q ( K1 - EE )     ::  :: quantifier_minus {{ tex [[Q]] ( [[K1]] \backslash_{[[EE]]} ) }}
  | Q ( K1 .... Ki ) ::  :: quantifier_mult
  | [ ckvs ]          ::  :: fill_kvs {{ tex [[ckvs]] }}
  | tsub ( EE )       ::  :: tsub

dctx, dd {{ tex \Psi}} , HH {{ tex \Psi }} :: 'dctx_' ::=
  | empty       ::   :: empty
  | dd , x : A  ::   :: cons_var
  | dd , f : A  ::   :: cons_var_f
  | HH , D : A         ::  :: dconstr
  | dd , a      ::   :: cons_tvar
  | [ OO ] DD     :: S :: ctx_subst
  | </ Di : Ai // i /> ::  :: dconstr_s
  | HH1 , .. , HHi     ::  :: append_multiple
  | tsub ( HH )        ::  :: tsub

sctx, ss {{ tex \Sigma }} :: 'sctx_' ::=
  | empty       ::   :: empty
  | A           ::   :: singleton
  | ss1 , ss2   ::   :: append


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO CONTEXT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

actx, GG {{ tex \Gamma}}, DD {{ tex \Delta }}, TT  {{ tex \Theta }}, OO {{ tex \Omega }}, DL {{ tex \Delta_L }}, DR {{ tex \Delta_R }}, GL {{ tex \Gamma_L }}, GR {{ tex \Gamma_R }}, GM {{ tex \Gamma_M }}, OL {{ tex \Omega_L }} , OR {{ tex \Omega_R }}, DDlo {{ tex \Delta^{\mathsf{lo} } }} :: 'actx_' ::=
  | empty                                     ::   :: empty
  | a : k                                     ::   :: cons_tvar2
  | a                                         ::   :: cons_tvar
  | evar                                      ::   :: cons_evar
  | evar : k                                  ::   :: cons_evar2
  | evar = at                                 ::   :: cons_evar_solu
  | evar =  t                                 ::   :: cons_evar_solu2
  | evar : K = k                              ::   :: kuvar_typed_solved
  | T : K                                     ::   :: cons_tvar3
  | T                                         ::   :: tconstr_s_untyped
  | ( GG )                                    :: S :: parens
  | DD1 , .... , DDi                          ::   :: append_multiple
  | x : aA                                    ::   :: cons_var
  | x :  A                                    ::   :: cons_var2
  | D : aA                                    ::   :: cons_data
  | D :  A                                    ::   :: cons_data2
  | marker D                                  ::   :: marker      {{ tex { \scriptstyle \blacktriangleright_{[[D]]} } }}
  | { DD }                                    ::  :: local_scope {{ tex \{ [[DD]] \} }}
  | ma                                        ::   :: cons_mark
  | [ ckvs ]                                  ::   :: fill_kvs {{ tex [[ckvs]] }}
  | GG [ TT ]                                       :: S :: ctx_tvar
  | [ aA ] GG                                      :: S :: subst_ctx {{ tex  \mathsf{contaminate}( [[GG]] , [[aA]] ) }}
  | | GG |                                         :: S :: solve_ctx
  | GG [ </ Ti |-> Ai // i /> ]      ::  :: subst_tcon_mult
  | GG [ </ kvsi |-> kvsi' // i /> ]      ::  :: subst_kvs
  | [ TT ] GG          ::  :: context_apply
  | unsolved ( DD )   ::  :: unsolved
  | topo ( DD )       ::  :: topo
  | [< DD >]           ::  :: placeholder {{ tex [[DD]] }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% F EXPR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fexp, es {{tex s}}, ef {{tex f}} :: 'ftrm_' ::=
  | 1              ::   :: one
  | x              ::   :: var
  | n              ::   :: lit
  | \ x : A . es   ::   :: absann
  | \ x . es       ::   :: abs
  | /\ avs . es    ::   :: tabs
  | es A           ::   :: tapp
  | es1 es2        ::   :: app
  | ( es )         :: S :: paren
  | | es |         ::   :: erase

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PBC EXPR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pexp, pe {{ tex s }}, rpe {{ tex r }}, CC {{ tex \mathcal{C} }} :: 'ptrm_' ::=
  | 1              ::   :: one
  | x              ::   :: var
  | f              ::   :: f
  | n              ::   :: lit
  | \ x : A . pe   ::   :: absann
  | pe1 pe2        ::   :: app {{ tex [[pe1]]~[[pe2]] }}
  | /\ a . pe      ::   :: tabs
  | < A `-> B > pe ::   :: cast
  | ( pe )         :: S :: paren
  | S ( pe )       :: S :: subst

pvalue, pv {{ tex v }} :: 'pvalue_' ::=
  | n              ::   :: lit
  | \ x : A . pe   ::   :: absann
  | /\ a . pe      ::   :: tabs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Kind Inference
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

program, pgm {{tex \mathit{pgm} }}:: 'pgm_' ::=
  | rec </ dti // i /> ; pgm    ::  :: rec_dt
  | dt ; pgm                    ::  :: dt
  | sig dtsig ; pgm             ::  :: dtsig
  | e                           ::  :: expr
  | tsub ( pgm )                ::  :: tsub

datatypesig, dtsig {{tex \mathcal{S} }}:: 'dtsig_' ::=
  | data T : K  :: :: data_cusk {{ tex \mathbf{data}~[[T]] : [[K]] }}

datatype, dt {{tex \mathcal{T} }} , dtt {{tex \mathcal{T} }} :: 'dt_' ::=
  | data T kvs =  </ dcj // j />  :: :: data_partial
  | data T : K ; Ty </ ai // i /> =  </ dcj // j />  :: :: data_cusk

dataconstr, dc {{tex \mathcal{D} }} , dcc {{tex \mathcal{D} }} :: 'dc_' ::=
  | D </ Ai // i />       ::  :: sigl
  | \/  kvs  . D </ Ai // i /> :: :: sigl_exist

typesubst, tsub {{ tex S }}, tsubstar {{tex S^{\star} }} :: 'tsub_' ::=

group :: 'group_' ::=
  | rec </ dti // i />  :: :: group

other_syntax :: 'other_' ::=
  | EE |- group ~~~>p kinds   :: :: princ

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TERMINALS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

terminals :: 'terminals_' ::=
  | topo       ::  :: topo {{tex \mathsf{topo} }}
  | ok      :: :: ok {{ tex \mathsf{ok} }}
  | ~       :: :: consist {{ tex \sim }}
  | ~=      :: :: approx {{ tex \approx }}
  | ->      :: :: arrow   {{ tex \rightarrow }}
  | ~~~>p        ::  :: princ {{ tex \leadsto^{\mathsf{p} } }}
  | --->    :: :: longarrow   {{ tex \rightarrow }}
  | --->>      :: :: two_head_long_rightarrow   {{ tex \longrightarrow\mathrel{\mkern-14mu}\rightarrow }}
  | star       :: :: star      {{ tex \star }}
  | let     :: :: let     {{ tex \mathbf{let} }}
  | fst     :: :: fst     {{ tex \mathbf{fst} }}
  | snd     :: :: snd     {{ tex \mathbf{snd} }}
  | int     :: :: int     {{ tex \mathsf{Int} }}
  | nat     :: :: nat     {{ tex \mathsf{Nat} }}
  | bool    :: :: bool    {{ tex \mathsf{Bool} }}
  | top     :: :: top     {{ tex \top }}
  | float     :: :: float     {{ tex \mathsf{Float} }}
  | notin    ::  :: notin {{ tex \notin       }}
  | fv       ::  :: fv {{ tex \textsc{fv}  }}
  | List     ::  :: list  {{ tex \mathsf{List} }}
  | Listu    ::  :: listu {{ tex \mathsf{List}_\unknown }}
  | n       :: :: lit     {{ tex \mathsf{n} }}
  | cons       :: :: cons     {{ tex \mathsf{cons} }}
  | consu       :: :: consu     {{ tex \mathsf{cons}_\unknown }}
  | nil       :: :: nil     {{ tex \mathsf{nil} }}
  | nilu       :: :: nilu     {{ tex \mathsf{nil}_\unknown }}
  | fold      :: :: fold   {{ tex \mathbf{fold} }}
  | unfold      :: :: unfold   {{ tex \mathbf{unfold} }}
  | .       :: :: dot     {{ tex .\, }}
  | unknown :: :: unknown {{ tex \mathit{\qm} }}
  | question ::  :: question {{ tex \mathit{?} }}
  | empty   :: :: empty   {{ tex \bullet }}
  | |-      :: :: turnstile {{ tex \vdash }}
  | |-OL    :: :: turnstile1 {{ tex \vdash^\mathit{OL} }}
  | |-HM    :: :: turnstile2 {{ tex \vdash^\mathit{HM} }}
  | |-DK    :: :: turnstile3 {{ tex \vdash^\mathit{DK} }}
  | |-AP    :: :: turnstile4 {{ tex \vdash^\mathit{AP} }}
  | |-F     :: :: turnstileF {{ tex \vdash^\mathit{F} }}
  | |-G     :: :: turnstileG {{ tex \vdash^\mathit{G} }}
  | |-Gm    :: :: turnstilem {{ tex \vdash^\mathit{G}_{m} }}
  | |-pr    :: :: turnstilepr {{ tex \vdash^{\!\!\mathsf{pr} } }}
  | |-u     :: :: turnstileu {{ tex \vdash^{\!\!\mathsf{u} } }}
  | |-wf    :: :: turnstilewf {{ tex \vdash^{\!\!\mathsf{wf} } }}
  | |-sub   :: :: turnstilesub {{ tex \vdash^{\!\!\mathsf{sub} } }}
  | -|      :: :: dashv {{ tex \dashv }}
  | ~>      :: :: mapsto    {{ tex \mapsto }}
  | |->     :: :: mapsto2   {{ tex \mapsto }}
  | <~      :: :: conssub   {{ tex \lesssim }}
  | <~~     :: :: inst   {{ tex \lessapprox }}
  | \       :: :: lambda    {{ tex \lambda }}
  | ~~>     :: :: translate {{ tex \rightsquigarrow }}
  | ~~~>    :: :: leadsto  {{ tex \leadsto }}
  | /\      :: :: tlambda   {{ tex \Lambda }}
  | Pi      :: :: pi        {{ tex \Pi }}
  | \/      :: :: forall   {{ tex \forall }}
  | `->     :: :: cast      {{ tex \hookrightarrow }}
  | <       :: :: lbr  {{ tex \langle }}
  | >       :: :: rbr  {{ tex \rangle }}
  | static  :: :: sta {{ tex \mathcal{S} }}
  | gradual :: :: gra {{ tex \mathcal{G} }}
  | |>      :: :: match {{ tex \triangleright  }}
  | =>      :: :: inf   {{ tex \Rightarrow }}
  | <=      :: :: chk   {{ tex \Leftarrow }}
  | =>=>    :: :: application {{ tex \Rightarrow\!\!\!\!\Rightarrow }}
  | -->     :: :: ext   {{ tex \longrightarrow }}
  | S       :: :: psubst {{ tex \psubst }}
  | blame   :: :: blame  {{ tex \mathsf{blame} }}
  | ==>     :: :: reduce {{ tex \Downarrow }}
  | <:      :: :: subtype {{ tex <: }}
  | =nid    :: :: etaid {{ tex =_{\eta id} }}
  | <<=     :: :: tless  {{ tex \sqsubseteq }}
  | rec        :: :: rec {{ tex \mathbf{rec} }}
  | sig        :: :: sig {{ tex \mathbf{sig} }}
  | |-p        :: :: vdashp {{ tex \vdash^{\!\!\mathsf{pgm} } }}
  | ||-u       :: :: vdashu {{ tex \Vdash^{\!\!\mathsf{u} } }}
  | ||-p       :: :: Vdashp {{ tex \Vdash^{\!\!\mathsf{pgm} } }}
  | |-el       :: :: vdashela {{ tex \vdash^{\!\!\mathsf{ela} } }}
  | ||-el      :: :: Vdashela {{ tex \Vdash^{\!\!\mathsf{ela} } }}
  | ||-dt      :: :: Vdashdt {{ tex \Vdash^{\!\!\mathsf{dt} } }}
  | |-dt       :: :: vdashdt {{ tex \vdash^{\!\!\mathsf{dt} } }}
  | |-pr       :: :: vdashpr {{ tex \Vdash^{\!\!\mathsf{pr} } }}
  | |-dc       :: :: vdashdc {{ tex \vdash^{\!\!\mathsf{dc} } }}
  | |-grp      :: :: vdashgrp {{ tex \vdash^{\!\!\mathsf{grp} } }}
  | ||-grp     :: :: Vdashgrp {{ tex \Vdash^{\!\!\mathsf{grp} } }}
  | |-sig      :: :: vdashsig {{ tex \vdash^{\!\!\mathsf{sig} } }}
  | |-k        :: :: vdashk {{ tex \vdash^{\!\!\mathsf{k} } }}
  | ||-k       :: :: Vdashk {{ tex \Vdash^{\!\!\mathsf{k} } }}
  | |-gen      :: :: vdashgen {{ tex \vdash^{\!\!\mathsf{gen} } }}
  | ||-gen     :: :: Vdashgen {{ tex \Vdash^{\!\!\mathsf{gen} } }}
  | |-inst     :: :: vdashinst {{ tex \vdash^{\!\!\mathsf{inst} } }}
  | ||-inst    :: :: Vdashinst {{ tex \Vdash^{\!\!\mathsf{inst} } }}
  | ||-kapp    :: :: Vdashkapp {{ tex \Vdash^{\!\!\mathsf{kapp} } }}
  | |-kc       :: :: vdashkc {{ tex \vdash^{\!\!\mathsf{kc} } }}
  | \bot       ::  :: bot {{ tex \bot }}


formula :: formula_ ::=
  | judgement             :: :: judgement
  | formula1 .. formulan            ::   :: dots
  | NOT ( formula )  ::  :: not {{ tex \neg ([[formula]]) }}
  | dd |- e => A          :: :: ap_inf_introduction
  | dd ; ss |- e => A     :: :: ap_app_introduction
  | |- A1 <: A2           :: :: ap_sub_introduction
  | ss |- A1 <: A2        :: :: ap_sub_introduction2
  | dd |-AP e => A        :: :: ap_inf_no_trans
  | dd ; ss |-AP e => A   :: :: ap_app_no_trans
  | |-AP A1 <: A2         :: :: ap_sub_no_trans
  | ss |-AP A1 <: A2      :: :: ap_app_sub_no_trans
  | a in dd               :: :: bind_tvar {{ tex [[a]] \in [[dd]] }}
  | r @ ( a ) in dd       :: :: bind_red_tvar {{ tex {\color{red} [[a]] } \in [[dd]] }}
  | b @ ( a ) in dd       :: :: bind_blue_tvar {{ tex {\color{blue} [[a]] } \in [[dd]] }}
  | a in GG               :: :: bind_tvar2 {{ tex [[a]] \in [[GG]] }}
  | ( x : A ) in dd       :: :: bind_var {{ tex ( [[x]] : [[A]] ) \in [[dd]] }}
  | ( x : aA ) in GG      :: :: bind_var2 {{ tex ( [[x]] : [[aA]] ) \in [[GG]] }}
  | evar in fv ( aA )     :: :: fv {{ tex [[evar]] \in \textsc{fv} ( [[aA]] ) }}
  | evar in GG            :: :: evargg {{ tex [[evar]] \in  [[GG]]  }}
  | ( Xa : K ) in DD  ::  :: xain {{ tex ( [[Xa]] : [[K]] ) \in [[DD]] }}
  | evar notin fv ( aA )  :: :: nfv {{ tex [[evar]] \notin \textsc{fv} ( [[aA]] ) }}
  | evar notin fv ( GG )  :: :: dfv {{ tex [[evar]] \notin \textsc{fv} ( [[GG]] ) }}
  | varset1 notin varset2     :: :: notin_varset
  | ma notin fv ( GG )     :: :: mafv {{ tex [[ma]] \notin \textsc{fv} ( [[GG]] ) }}
  | aA1 = aA2             :: :: eq
  | dd |- e : A           :: :: typ
  | dd |- e => A           :: :: typ_inf
  | dd |- e <= A           :: :: typ_chk
  | dd |- pe : A :: :: ptyp {{ tex [[dd]] \vdash^\mathit{B} [[pe]] : [[A]] }}
  | CC : ( dd |- A ) ~~> ( dd' |- A' ) :: :: ctx {{ tex [[CC]] : ( [[dd]] \vdash^\mathit{B} [[A]] ) \rightsquigarrow ( [[dd']] \vdash^\mathit{B} [[A']] ) }}
  | A1 <: A2 :: :: sub
  | A1 <~ A2 :: :: csub
  | || A ||               :: :: sizeA {{ tex \llbracket [[A]] \rrbracket }}
  | || e ||e              :: :: sizeE {{ tex \llbracket [[e]] \rrbracket_\mathcal{E} }}
  | || pe ||              :: :: size {{ tex \llbracket [[pe]] \rrbracket }}
  | || pe ||e             :: :: size_e {{ tex \llbracket [[pe]] \rrbracket_\mathcal{E} }}
  | || pe ||s             :: :: size_s {{ tex \llbracket [[pe]] \rrbracket_\mathcal{S} }}
  | || pe ||g             :: :: size_g {{ tex \llbracket [[pe]] \rrbracket_\mathcal{G} }}
  | dd1 | dd2 |- pe1 <<= pe2 :: :: bless {{ tex [[dd1]] \shortmid [[dd2]] \vdash [[pe1]] \sqsubseteq^\mathit{B} [[pe2]] }}
  | aA <~~ evar    :: :: inst
  | evar <~~ aA    :: :: inst2
  | \ pe \   ::  :: type_erasure {{ tex \lfloor [[pe]] \rfloor }}
  | pe ==> pv  ::  :: reduce 
  | pe ==> blame  ::  :: blame
  | e1 = e2       ::  :: expr_eq
  | aA1 <~ aA2 :: :: algo
  | A1 = A2    ::  :: typ_eq
  | DD1 = DD2    ::  :: DD_eq
  | avs1 = avs2 ::  :: avs_eq
  | A `-> B   :: :: cast
  | < A `-> B >   :: :: cast2
  | dd |-G e : A  ::  :: dtyping_without
  | dd |-Gm e : A  ::  :: dtyping_m
  | dd |-sub A1 <: A2  ::  :: dsub_pr
  | ( T : K ) in DD  ::  :: atin {{ tex ( [[T]] : [[K]] ) \in [[DD]] }}
  | ( T : K ) in EE  ::  :: tin {{ tex ( [[T]] : [[K]] ) \in [[EE]] }}
  | EE1 = EE2        ::  :: tctx_eq
  | ( a : K ) in DD  ::  :: aain {{ tex ( [[a]] : [[K]] ) \in [[DD]] }}
  | kvs in EE        ::  :: kvs_in_quantifier {{ tex [[kvs]] \in [[EE]] }}
  | kvs1 = kvs2      ::  :: eq_kvs
  | kvs1 # kvs2           ::  :: set_disjoint  {{ tex [[kvs1]]~\sharp~[[kvs2]] }}
  | EE |-grp rec </ dti // i /> ~~~> </ Kj // j /> ; </ HHl // l /> :: :: typing_rec
  | DD ||-grp rec </ dti // i /> ~~~> </ Kj // j /> ; </ GGl // l /> -| TT :: :: typing_rec_algo
  | DD ||-grp rec </ dti // i /> ~~~> </ Kj // j /> ; </ GGl // l /> :: :: typing_rec_algo_gen
  | K1 ~= K2           ::  :: unify
  | DD |- eK1 ~= eK2   ::  :: wip_unif
  | HH1 = HH2        ::  :: ectx_eq


subrules
  t <:: A
  gc <:: A
  tc <:: t
  tc <:: t
  aT <:: aA
  at <:: aT
  atc <:: at
  agc <:: aA
  asc <:: agc
  pv <:: pe

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FOB
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
FOb :: 'FOb_' ::=

defn

A ~ B ::  :: consist :: consist_ by


------- :: refl
A ~ A


------------- :: unknownR
A ~ unknown

------------- :: unknownL
unknown ~ A


A1 ~ C
B ~ A4
-------------------- :: arrow
A1 -> B ~ C -> A4

</ Ai ~ Ai' // i />
-------------------------------------------------- :: rcd
[ </ li : Ai // i />  ]   ~ [ </ li : Ai' // i /> ]


defn

A <: B ::  :: subtyping :: s_ by

-------------------- :: int
int <: int

-------------------- :: bool
bool <: bool

-------------------- :: float
float <: float

-------------------- :: intfloat
int <: float

C <: A1
B <: A4
-------------------- :: arrow
A1 -> B <: C -> A4

-------------------- :: unknown
unknown <: unknown

</ Ai <: Ai' // i />
-------------------------------------------------- :: rcd
[ </ li : Ai // i />  ]   <: [ </ li : Ai' // i /> ]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL CONSISTENCY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DConsist :: '' ::=

defn

A ~ B ::  :: dconsist :: dconsist_ by


------- :: refl
A ~ A

------- :: top
top ~ top


------------- :: unknownR
A ~ unknown

------------- :: unknownL
unknown ~ A


A1 ~ C
B ~ A4
-------------------- :: arrow
A1 -> B ~ C -> A4

A ~ B
------------------ :: forall
\/ a. A ~ \/ a. B

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL WELL FORMEDNESS OF TYPES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DWft :: '' ::=

defn

dd |-DK A ::  :: dkwft :: dk_wf_ by

defn

dd |-OL A ::  :: odwft :: ol_wf_ by

--------- :: int
dd |-OL int

a in dd
-------- :: tvar
dd |-OL a

dd |-OL A1
dd |-OL A2
-------------- :: arrow
dd |-OL A1 -> A2

dd, a |-OL A
-------------- :: forall
dd |-OL \/ a. A

defn

dd |-G A ::  :: dwft :: gpc_d_ by

--------- :: int
dd |-G int


--------- :: unknown
dd |-G unknown


-------------- :: static
dd |-G static

-------------- :: gradual
dd |-G gradual


a in dd
-------- :: tvar
dd |-G a

dd |-G A
dd |-G B
-------------- :: arrow
dd |-G A -> B

dd, a |-G A
-------------- :: forall
dd |-G \/ a. A

defn

dd ok :: :: ol_well_formed_tctx :: 'ol_cwf_' {{ tex [[dd]] \ [[ok]] }} by

------------------------- :: empty
empty ok

dd ok
dd |-OL A
------------------------- :: var
dd , x : A ok

dd ok
------------------------- :: tvar
dd , a ok

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL SUBTYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DSubtyping :: '' ::=

defn

|-HM A <: B ::  :: hm_subtyping :: hm_s_ by

-------------------- :: refl
|-HM t <: t

|-HM A1 [a ~> t] <: A2
----------------- :: forallL
|-HM \/ a. A1 <: A2

a notin fv(A1)
|-HM A1 <: A2
----------------- :: forallR
|-HM A1 <: \/ a . A2


defn

dd |-OL A <: B ::  :: ol_subtyping :: ol_s_ by

a in dd
-------------------- :: tvar
dd |-OL a <: a

-------------------- :: int
dd |-OL int <: int

dd |-OL A3 <: A1
dd |-OL A2 <: A4
---------------------------- :: arrow
dd |-OL A1 -> A2 <: A3 -> A4

dd |-OL t
dd |-OL A [a ~> t] <: A2
----------------- :: forallL
dd |-OL \/ a. A1 <: A2

dd, a |-OL A1 <: A2
----------------- :: forallR
dd |-OL A1 <: \/ a. A2

defn

dd |-DK A <: B ::  :: dk_subtyping :: dk_s_ by

defn

|-AP A <: B ~~> ef ::  :: ap_subtyping :: ap_s_
{{tex [[|-AP]] [[A]] [[<:]] [[B]] \transto{[[~~>]] [[ef]]} }}
by

------------------ :: int
|-AP int <: int ~~> \x:int. x

------------------ :: tvar
|-AP a <: a ~~> \x:a . x

|-AP A3 <: A1 ~~> ef1
|-AP A2 <: A4 ~~> ef2
---------------------------- :: arrow
|-AP A1 -> A2 <: A3 -> A4  ~~> \x:A1->A2. \y:A3. ef2 (x (ef1 y))

|-AP A [a ~> t] <: A2 ~~> ef
----------------- :: forallL
|-AP \/ a. A1 <: A2 ~~> \x:\/a.A1. ef (x t)

a notin fv(A1)
|-AP A1 <: A2 ~~> ef
----------------- :: forallR
|-AP A1 <: \/ a. A2 ~~> \x:A1. /\a. ef x

|-AP A1 <: C ~~> ef1
|-AP B <: A4 ~~> ef2
----------------------- :: pair
|-AP (A1, B) <: (C, A4) ~~> ef3

defn

ss |-AP A <: B ~~> ef ::  :: ap_asubtyping :: ap_as_
{{ tex [[ss]] [[|-AP]] [[A]] [[<:]] [[B]] \transto{[[~~>]] [[ef]]} }}
by

---------------- :: empty
empty |-AP A <: A ~~> \x:A. x


ss, A3 |-AP A1 [a ~> t] <: A2 ~~> ef
------------------------ :: forall
ss, A3 |-AP \/a. A1 <: A2 ~~> \x:\/a.A1. ef (x t)


|-AP A3 <: A1 ~~> ef1
ss |-AP A2 <: A4 ~~> ef2
------------------------ :: arrow
ss, A3 |-AP A1 -> A2 <: A3 -> A4 ~~> \x:A1->A2.\y:A3. ef2 (x (ef1 y))

defn

dd |-G A <: B ::  :: dsubtyping :: gpc_s_ by


dd, a |-G A <: B
----------------- :: forallR
dd |-G A <: \/ a. B


dd |-G t
dd |-G A [a ~> t] <: B
----------------- :: forallL
dd |-G \/ a. A <: B


a in dd
-------------------- :: tvar
dd |-G a <: a

-------------------- :: int
dd |-G int <: int



dd |-G C <: A1
dd |-G B <: A4
---------------------------- :: arrow
dd |-G A1 -> B <: C -> A4


--------------------------- :: unknown
dd |-G unknown <: unknown


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL CONSISTENT SUBTYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DConSub :: '' ::=

defn

dd |-G A <~ B ::  :: dconsub :: gpc_cs_ by

---------------- :: top
dd |-G A <~ top

dd, a |-G A1 <~ B
----------------- :: forallR
dd |-G A1 <~ \/ a. B

dd |-G t
dd |-G A1 [a ~> t] <~ B
----------------- :: forallL
dd |-G \/ a. A1 <~ B

dd |-G C <~ A1
dd |-G B <~ A4
---------------------------- :: arrow
dd |-G A1 -> B <~ C -> A4

a in dd
-------------------- :: tvar
dd |-G a <~ a

-------------------- :: int
dd |-G int <~ int


--------------------------- :: unknownL
dd |-G unknown <~ A

--------------------------- :: unknownR
dd |-G A <~ unknown


--------------------------- :: unknownLL
dd |-G unknown <~ gc

--------------------------- :: unknownRR
dd |-G gc <~ unknown

--------------------------- :: spar
dd |-G static <~ static

--------------------------- :: gpar
dd |-G gradual <~ gradual


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL TYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DTyping :: '' ::=

defn

dd |-G e : A ~~> pe ::  :: dtyping :: 'gpc_' {{ tex [[dd]] [[|-G]] [[e]] : [[A]] \transto{[[~~>]] [[pe]]} }}
by


(x : A) in dd
--------------------------- :: var
dd |-G x : A ~~> x

--------------------------- :: int
dd |-G n : int ~~> n

dd, a |-G e : A ~~> pe
--------------------------- :: gen
dd |-G e : \/ a. A ~~> /\a. pe

dd, x: A |-G e : B ~~> pe
--------------------------- :: lamann
dd |-G \x: A. e : A -> B ~~> \x:A. pe

dd, x: t |-G e : B ~~> pe
--------------------------- :: lam
dd |-G \x. e : t -> B ~~> \x:t. pe

dd |-G e1 : A ~~> pe1
dd |-G A |> A1 -> A2
dd |-G e2 : A3 ~~> pe2
dd |-G A3 <~ A1
------------------------------- :: app
dd |-G e1 e2 : A2 ~~> (< A `-> A1 -> A2 > pe1) (<A3 `-> A1> pe2)


dd |-G e1 : A ~~> pe1
dd, x : A |-G e2 : B ~~> pe2
--------------------------------------------------- :: let
dd |-G let x = e1 in e2 : B ~~>  (\x : A . pe2) pe1

defn

dd |-HM e : A  ::  :: hmtyping :: 'hm_' by

(x : A) in dd
--------------------------- :: var
dd |-HM x : A

--------------------------- :: int
dd |-HM n : int

</ ai // i /> notin fv(dd)
dd |-HM e : t
--------------------------- :: gen
dd |-HM e : \/ </ ai // i />  . t

dd, x: t1 |-HM e : t2
--------------------------- :: lam
dd |-HM \x. e : t1 -> t2

dd |-HM e1 : t1 -> t2
dd |-HM e2 : t1
------------------------------- :: app
dd |-HM e1 e2 : t2

dd |-HM e1 : A
dd, x : A |-HM e2 : t
------------------------------ :: let
dd |-HM let x = e1 in e2 : t

dd |-HM e : \/ </ ai // i /> . t
--------------------------- :: inst
dd |-HM e : t [ </ ai ~> ti // i /> ]

(x : \/ </ ai // i /> . t) in dd
--------------------------- :: var_inst
dd |-HM x : t [ </ ai ~> ti // i /> ]

dd |-HM e1 : t
</ ai // i /> = fv (t) - fv(dd)
dd, x : \/ </ ai // i/> . t |-HM e2 : t
--------------------------------------- :: let_gen
dd |-HM let x = e1 in e2 : t


defn

dd |-OL e : A  ::  :: ol_dtyping :: 'ol_' by


(x : A) in dd
--------------------------- :: var
dd |-OL x : A

--------------------------- :: int
dd |-OL n : int

dd, a |-OL e : A
--------------------------- :: gen
dd |-OL e : \/ a. A

dd, x: A1 |-OL e : A2
--------------------------- :: lamann
dd |-OL \x: A1. e : A1 -> A2

dd |-OL t
dd, x: t |-OL e : A
--------------------------- :: lam
dd |-OL \x. e : t -> A

dd |-OL e1 : A1 -> A2
dd |-OL e2 : A1
------------------------------- :: app
dd |-OL e1 e2 : A2


dd |-OL e : A1
dd |-OL A1 <: A2
--------------------------- :: sub
dd |-OL e : A2


dd |-OL e1 : A1
dd, x : A1 |-OL e2 : A2
------------------------------ :: let
dd |-OL let x = e1 in e2 : A2

defn

dd |-DK e => A  ::  :: dk_inf :: 'dk_inf_' by

(x : A) in dd
--------------------------- :: var
dd |-DK x => A

--------------------------- :: int
dd |-DK n => int

dd |-DK t1 -> t2
dd, x: t1 |-DK e => t2
--------------------------- :: lam
dd |-DK \x. e => t1 -> t2

dd |-DK e1 => A
dd |-DK A |> A1 -> A2
dd |-DK e2 <= A1
------------------------------- :: app
dd |-DK e1 e2 => A2

dd |-DK e <= A
--------------------------- :: anno
dd |-DK e : A => A

dd |-DK e1 => A
dd |-DK A . e2 =>=> A2
------------------------------- :: app2
dd |-DK e1 e2 => A2

defn

dd |-DK e <= A  ::  :: dk_chk :: 'dk_chk_' by

--------------------------- :: int
dd |-DK n <= int

dd, a |-DK e <= A
--------------------------- :: gen
dd |-DK e <= \/ a. A


dd, x: A1 |-DK e <= A2
--------------------------- :: lam
dd |-DK \x. e <= A1 -> A2


dd |-DK e => A1
dd |-DK A1 <: A2
--------------------------- :: sub
dd |-DK e <= A2


defn

dd |-DK A1 . e =>=> A  ::  :: dk_app :: 'dk_app_'
{{ tex [[dd]] [[|-DK]] [[A1]] \cdot [[e]] [[=>=>]] [[A]] }}
by

dd |-DK e <= A1
--------------------------- :: arr
dd |-DK A1 -> A2 . e =>=> A2

dd |-DK t
dd |-DK A[a ~> t] . e =>=> A1 -> A2
--------------------------- :: forall
dd |-DK \/a. A . e =>=> A1 -> A2

defn

dd ; ss |-AP e => A ~~> es  ::  :: ap_app :: 'ap_app_'
{{ tex [[dd]] ; [[ss]] [[|-AP]] [[e]] [[=>]] [[A]] \transto{[[~~>]] [[es]]} }}
by

dd |-AP e <= A1
ss |-AP A1 <: B
------------------------ :: anno
dd;ss |-AP e : A1 => B ~~> es

(x : A1) in dd
ss |-AP A1 <: A2 ~~> ef
--------------------------- :: var
dd ; ss |-AP x => A2 ~~> ef x

dd, x: A1 |-AP e => A2 ~~> es
--------------------------- :: lam
dd ; ss , A1 |-AP \x. e => A1 -> A2 ~~> \x:A1. es


|-AP A2 <: A1  ~~> ef
dd, x: A1 |-AP e => A3 ~~> es
--------------------------- :: lamann
dd ; ss, A2 |-AP \x: A1. e => A2 -> A3 ~~> \y:A2. (\x:A1. es) (ef y)


dd |-AP e2 => A1 ~~> es2
</ ai // i /> =  fv(A1) - fv(dd)
A2 = \/ </ai//i/> . A1
dd ; ss, A2 |-AP e1 => A2 -> A3 ~~> es1
------------------------------- :: app
dd ; ss |-AP e1 e2 => A3 ~~> es1 (/\ </ai//i/>. es2)


dd |-AP e => (A1, B)
ss |-AP A1 <: C
------------------------ :: fst
dd ; ss |-AP fst e => C ~~> es

dd |-AP e => (A1, B)
ss |-AP B <: C
------------------------ :: snd
dd ; ss |-AP snd e => C ~~> es

ss |-AP \/a.\/b. (a, b) -> a <: A
------------------------ :: fst_var
dd ; ss |-AP fst => A ~~> es

ss |-AP \/a.\/b. (a, b) -> b <: A
------------------------ :: snd_var
dd ; ss |-AP snd => A ~~> es

defn

dd |-gen A1 = A2 ::  :: ap_gen :: 'ap_gen' {{ tex [[dd]]_{gen} ([[A1]]) = [[A2]] }} by

defn

dd |-AP e => A ~~> ef  ::  :: ap_inf :: 'ap_inf_'
{{ tex [[dd]] [[|-AP]] [[e]] [[=>]] [[A]] \transto{[[~~>]] [[ef]]} }}

by

--------------------------- :: int
dd |-AP n => int ~~> n

dd, x: t |-AP e => A ~~> es
--------------------------- :: lam
dd |-AP \x. e => t -> A ~~> \x:t. es

dd , x: A1 |-AP e => A2 ~~> es
--------------------------- :: lamann
dd  |-AP \x: A1. e => A1 -> A2 ~~> \x:A1.es

dd |-AP e1 => A1
dd |-AP e2 => B
--------------------------- :: pair
dd |-AP (e1, e2) => (A1, B) ~~> es

defn

dd |-AP e <= A  ::  :: ap_chk :: 'ap_chk_' by

dd, x : A1 |-AP e <= B
-------------------------- :: lam
dd |-AP \x.e <= A1 -> B


dd |-AP e2 => A1
dd |-AP e1 <= A1 -> B
--------------------- :: app
dd |-AP e1 e2 <= B

defn

dd |-F es : A         ::  :: f_     :: 'f_' by

(x : A) in dd
--------------------------- :: var
dd |-F x : A

--------------------------- :: int
dd |-F n : int

dd, x: A1 |-F es : A2
--------------------------- :: lamann
dd |-F \x: A1. es : A1 -> A2

dd |-F es1 : A1 -> A2
dd |-F es2 : A1
------------------------------- :: app
dd |-F es1 es2 : A2

dd |-F es : A
a notin fv(dd)
------------------------------- :: tabs
dd |-F /\a. es : \/a. A


dd |-F es : \/a. A1
------------------------------- :: tapp
dd |-F es A2 : A1 [a~>A2]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Eta ID Equality
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DEq :: '' ::=

defn

ef1 =nid ef2   ::  :: etaid :: eta_ by

x notin fv(ef)
------------------ :: reduce
\x. ef x =nid ef

-------------------- :: id
(\x. x) ef =nid ef

ef1 =nid ef1'
ef2 =nid ef2'
--------------------------- :: app
ef1 ef2 =nid ef1' ef2'

ef =nid ef'
------------------- :: lam
\x. ef =nid \x. ef'

-------------------- :: refl
ef =nid ef

ef =nid ef'
-------------------- :: symm
ef' =nid ef

ef1 =nid ef2
ef2 =nid ef3
-------------------- :: trans
ef1 =nid ef3

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL MATCHING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
DMatching :: '' ::=

defn

dd |-DK A |> B ::  :: dk_matching :: dk_m_ by


dd |-DK t
dd |-DK A [a ~> t] |> A1 -> A2
-------------------------------- :: forall
dd |-DK \/ a . A |> A1 -> A2


-------------------------- :: arr
dd |-DK A1 -> A2 |> A1 -> A2

defn

dd |-G A |> B ::  :: dmatching :: gpc_m_ by


dd |-G t
dd |-G A [a ~> t] |> A1 -> A2
-------------------------------- :: forall
dd |-G \/ a . A |> A1 -> A2


-------------------------- :: arr
dd |-G A1 -> A2 |> A1 -> A2


-------------------------------------- :: unknown
dd |-G unknown |> unknown -> unknown



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% WELL FORMEDNESS OF ALGO CONTEXTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Wfc :: 'gpc_' ::=

defn

|-G GG ::  :: wfc :: wf_ by




----------------------- :: empty
|-G empty


|-G GG
x notin fv(GG)
GG |-G aA
----------------- :: var
|-G GG , x : aA



|-G GG
a notin fv(GG)
----------------- :: tvar
|-G GG , a


|-G GG
evar notin fv(GG)
----------------- :: evar
|-G GG , evar


|-G GG
evar notin fv(GG)
GG |-G at
----------------- :: solved
|-G GG , evar = at

|-G GG
mevar notin fv(GG)
----------------- :: marker
|-G GG , mevar



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO WELL FORMEDNESS OF TYPES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
AWft :: 'gpc_' ::=

defn

GG |-G aA ::  :: awft :: ad_ by

--------- :: int
GG |-G int


--------- :: unknown
GG |-G unknown


--------- :: static
GG |-G static


--------- :: gradual
GG |-G gradual


-------- :: tvar
GG[a] |-G a


------------------ :: evar
GG[evar] |-G evar


------------------ :: solved
GG[evar = at] |-G evar


GG |-G aA1
GG |-G aA2
-------------- :: arrow
GG |-G aA1 -> aA2

GG, a |-G aA
-------------- :: forall
GG |-G \/ a. aA



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO CONSISTENT SUBTYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
AConSub :: 'gpc_' ::=

defn

GG |-G aA1 <~ aA2 -| DD ::  :: aconsub :: as_
by


-------------------------- :: tvar
GG[a] |-G a <~ a -| GG[a]



-------------------------- :: evar
GG[evar] |-G evar <~ evar -| GG[evar]


-------------------- :: int
GG |-G int <~ int -| GG


GG |-G aA3 <~ aA1 -| TT
TT |-G [TT] aA2 <~ [TT] aA4 -| DD
----------------------------------------- :: arrow
GG |-G aA1 -> aA2 <~ aA3 -> aA4 -| DD


GG, a |-G aA1 <~ aA2 -| DD, a, TT
----------------------------- :: forallR
GG |-G aA1 <~ \/ a. aA2 -| DD


GG, mevar, evar |-G aA1 [a ~> evar] <~ aA2 -| DD, mevar, TT
------------------------------ :: forallL
GG |-G \/ a. aA1 <~ aA2 -| DD


GG, msa, sa |-G aA1 [a ~> sa] <~ aA2 -| DD, msa, TT
------------------------------ :: forallLL
GG |-G \/ a. aA1 <~ aA2 -| DD


--------------------------- :: spar
GG |-G static <~ static -| GG

--------------------------- :: gpar
GG |-G gradual <~ gradual -| GG


--------------------------- :: unknownL
GG |-G unknown <~ aA -| GG

--------------------------- :: unknownR
GG |-G aA <~ unknown -| GG


--------------------------- :: unknownLL
GG |-G unknown <~ agc -| [agc] GG

--------------------------- :: unknownRR
GG |-G agc <~ unknown -| [agc] GG


evar notin fv(aA)
GG[evar] |-G evar <~~ aA -| DD
---------------------------------- :: instL
GG[evar] |-G  evar <~ aA -| DD



evar notin fv(aA)
GG[evar] |-G aA <~~ evar -| DD
---------------------------------- :: instR
GG[evar] |-G  aA <~ evar -| DD


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INSTANTIATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
AInst :: 'gpc_' ::=

defn

GG |-G evar <~~ aA -| DD :: :: instl :: instl_
by



GG |-G at
--------------------------------------------- :: solve
GG, evar, GG' |-G evar <~~ at -| GG, evar = at, GG'


--------------------------------------------- :: solveU
GG[evar] |-G evar <~~ unknown -| GG[evar]



GG |-G at
--------------------------------------------- :: solveS
GG, sa, GG' |-G sa <~~ at -| GG, sa = at, GG'


GG |-G atc
--------------------------------------------- :: solveG
GG, ga, GG' |-G ga <~~ atc -| GG, ga = atc, GG'



--------------------------------------------- :: solveUS
GG[sa] |-G sa <~~ unknown -| GG[ga, sa = ga]


--------------------------------------------- :: solveUG
GG[ga] |-G ga <~~ unknown -| GG[ga]


------------------------------------------------------------- :: reach
GG[evar][evarb] |-G evar <~~ evarb -| GG[evar][evarb = evar]


------------------------------------------------------------- :: reachSG1
GG[sa][gb] |-G sa <~~ gb -| GG[ga , sa = ga][gb = ga]


------------------------------------------------------------- :: reachSG2
GG[sb][ga] |-G ga <~~ sb -| GG[gb , sb = gb][ga = gb]


------------------------------------------------------------- :: reachOther
GG[evar][evarb] |-G evar <~~ evarb -| GG[evar][evarb = evar]




GG[evar2, evar1, evar = evar1 -> evar2] |-G aA1 <~~ evar1 -| TT
TT |-G evar2 <~~ [TT]aA2 -| DD
----------------------------------------------------------------- :: arr
GG[evar] |-G evar <~~ aA1 -> aA2 -| DD




GG[evar] , b |-G evar <~~ aA -| DD , b , TT
--------------------------------------- :: forallR
GG[evar] |-G evar <~~ \/b . aA -| DD




defn
GG |-G aA <~~ evar -| DD :: :: instr :: instr_
by

GG |-G at
--------------------------------------------- :: solve
GG, evar, GG' |-G at <~~ evar -| GG, evar = at, GG'


--------------------------------------------- :: solveU
GG[evar] |-G unknown <~~ evar -| GG[evar]

GG |-G at
--------------------------------------------- :: solveS
GG, sa, GG' |-G at <~~ sa -| GG, sa = at, GG'


GG |-G atc
--------------------------------------------- :: solveG
GG, ga, GG' |-G atc <~~ ga -| GG, ga = atc, GG'



--------------------------------------------- :: solveUS
GG[sa] |-G unknown  <~~ sa  -| GG[ga, sa = ga]


--------------------------------------------- :: solveUG
GG[ga] |-G unknown  <~~ ga  -| GG[ga]



------------------------------------------------------------- :: reach
GG[evar][evarb] |-G evarb <~~ evar -| GG[evar][evarb = evar]


------------------------------------------------------------- :: reachSG1
GG[sa][gb] |-G gb <~~ sa -| GG[ga , sa = ga][gb = ga]


------------------------------------------------------------- :: reachSG2
GG[sb][ga] |-G sb <~~ ga -| GG[gb , sb = gb][ga = gb]


------------------------------------------------------------- :: reachOther
GG[evar][evarb] |-G evarb <~~ evar -| GG[evar][evarb = evar]




GG[evar2, evar1, evar = evar1 -> evar2] |-G evar1 <~~ aA1 -| TT
TT |-G [TT]aA2 <~~ evar2  -| DD
----------------------------------------------------------------- :: arr
GG[evar] |-G aA1 -> aA2  <~~ evar -| DD


GG[evar] , mevarb, evarb |-G aA[b ~> evarb] <~~ evar -| DD, mevarb, TT
-------------------------------------------------- :: forallL
GG[evar] |-G \/b . aA <~~ evar -| DD


GG[evar] , msb, sb |-G aA[b ~> sb] <~~ evar -| DD, msb, TT
-------------------------------------------------- :: forallLL
GG[evar] |-G \/b . aA <~~ evar -| DD



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO TYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
ATyping :: 'gpc_' ::=

defn

GG |-G ae => aA -| DD ::  :: inf :: 'inf_'
by

(x : aA) in GG
--------------------------- :: var
GG |-G x => aA -| GG



--------------------------- :: int
GG |-G n => int -| GG


GG |-G aA
GG, evarb,  x: aA |-G ae <= evarb -| DD, x : aA, TT
------------------------------------------- :: lamann
GG |-G \x: aA. ae => aA -> evarb -| DD


GG |-G aA
GG, sb,  x: aA |-G ae <= sb -| DD, x : aA, TT
------------------------------------------- :: lamann2
GG |-G \x: aA. ae => aA -> sb -| DD


GG, evar, evarb, x : evar |-G ae <= evarb -| DD, x : evar, TT
------------------------------------ :: lam
GG |-G \x. ae => evar -> evarb  -| DD


GG, sa, sb, x : sa |-G ae <= sb -| DD, x : sa, TT
------------------------------------ :: lam2
GG |-G \x. ae => sa -> sb  -| DD


GG |-G ae1 => aA -| TT1
TT1 |-G [TT1] aA |> aA1 -> aA2 -| TT2
TT2 |-G ae2 <= [TT2]aA1 -| DD
------------------------------- :: app
GG |-G ae1 ae2 => aA2  -| DD



GG |-G aA
GG |-G ae <= aA -| DD
---------------------- :: anno
GG |-G ae : aA => aA -| DD


GG |-G ae1 => aA -| TT1
TT1, evar, x : aA |-G ae2 <= evar -| DD, x : aA, TT2
------------------------------------------------ :: let
GG |-G let x = ae1 in ae2 => evar -| DD


GG |-G ae1 => aA -| TT1
TT1, sa, x : aA |-G ae2 <= sa -| DD, x : aA, TT2
------------------------------------------------ :: let2
GG |-G let x = ae1 in ae2 => sa -| DD

defn

GG |-G ae <= aA -| DD ::  :: chk :: 'chk_'
by


GG, a |-G ae <= aA -| DD , a , TT
--------------------------- :: gen
GG |-G ae <= \/ a. aA -| DD



GG, x : aA1 |-G ae <= aA2 -| DD, x : aA1, TT
------------------------------------ :: lam
GG |-G \x. ae <= aA1 -> aA2  -| DD


GG |-G ae => aA1 -| TT
TT |-G [TT]aA1 <~ [TT]aA2 -| DD
------------------------------------ :: sub
GG |-G ae <= aA2 -| DD


GG |-G ae1 => aA -| TT
TT, x : aA |-G ae2 <= aB -| DD, x : aA, TT'
------------------------------------------------ :: let
GG |-G let x = ae1 in ae2 <= aB -| DD



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO MATCHING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
AMatching :: 'gpc_' ::=

defn

GG |-G aA |> aA1 -> aA2 -| DD ::  :: amatching :: am_
by



GG , evar |-G aA[a ~> evar] |> aA1 -> aA2 -| DD
-------------------------------------------- :: forall
GG |-G \/a. aA |> aA1 -> aA2 -| DD


GG , sa |-G aA[a ~> sa] |> aA1 -> aA2 -| DD
-------------------------------------------- :: forallL
GG |-G \/a. aA |> aA1 -> aA2 -| DD


------------------------------------------ :: arr
GG |-G  aA1 -> aA2 |> aA1 -> aA2 -| GG


------------------------------------------ :: unknown
GG |-G  unknown |> unknown -> unknown -| GG


---------------------------------------------------------------------------------- :: var
GG[evar] |-G  evar |> evar1 -> evar2 -| GG[evar1 , evar2 , evar = evar1 -> evar2]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONTEXT EXTENSION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Extension :: 'gpc_' ::=


defn

GG --> DD :: :: cext :: 'ext_' by



--------------- :: id
empty --> empty



GG --> DD
[DD] aA = [DD] aA'
-------------------------------- :: var
GG , x : aA --> DD , x : aA'


GG --> DD
-------------------- :: tvar
GG , a  -->  DD , a


GG --> DD
------------------------- :: evar
GG , evar --> DD , evar


GG --> DD
[DD] at = [DD] at'
------------------------------------- :: solved
GG , evar = at --> DD , evar = at'


GG --> DD
------------------------------------- :: solve
GG , evar  --> DD , evar = at


GG --> DD
------------------------------------- :: solveS
GG , sa  --> DD , sa = at


GG --> DD
------------------------------------- :: solveG
GG , ga --> DD , ga = atc


GG --> DD
------------------------------------- :: add
GG  --> DD , evar


GG --> DD
------------------------------------- :: marker
GG, mevar  --> DD , mevar



GG --> DD
------------------------------------- :: addSolve
GG  --> DD , evar = at



GG --> DD
------------------------------------- :: addSolveS
GG  --> DD , sa = at


GG --> DD
------------------------------------- :: addSolveG
GG  --> DD , ga = atc

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LESS PRECISE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Lessp :: '' ::=

defn

A <<= B :: :: type :: 'gpc_l_' by

----------------- :: unknown
unknown <<= A


----------------- :: int
int <<= int

A1 <<= A3
A2 <<= A4
----------------- :: arrow
A1 -> A2 <<= A3 -> A4

----------------- :: tvar
a <<= a

A1 <<= A2
----------------- :: forall
\/a. A1 <<= \/a. A2

defn

e1 <<= e2 :: :: expr :: 'gpc_le_' by


--------------- :: refl
e <<= e

A1 <<= A2
e1 <<= e2
--------------- :: lamann
\x:A1. e1 <<= \x:A2.e2

e1 <<= e3
e2 <<= e4
--------------- :: app
e1 e2 <<= e3 e4

defn

pe1 <<= pe2 :: :: pbc :: 'b_le_' by


--------------- :: var
x <<= x

--------------- :: nat
n <<= n

A1 <<= A2
pe1 <<= pe2
--------------- :: lamann
\x:A1. pe1 <<= \x:A2. pe2

pe1 <<= pe2
--------------- :: tabs
/\a. pe1 <<= /\a. pe2

pe1 <<= pe3
pe2 <<= pe4
--------------- :: app
pe1 pe2 <<= pe3 pe4

A1 <<= A3
A2 <<= A4
pe1 <<= pe2
--------------- :: cast
<A1 `-> A2> pe1 <<= <A3 `-> A4> pe2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Promotion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns

promotion :: '' ::=

defn

DD |-pr ( evar ) aA ~~> at2 -| TT ::  :: promotion :: 'pr_'
{{ tex [[DD]] [[|-pr]]_{\!\![[evar]]} [[aA]] [[~~>]] [[at2]] [[-|]] [[TT]] }}
by

-------------------------- :: int
GG |-pr (evar) int ~~> int -| GG

-------------------------- :: tvar
GG[a][evar] |-pr (evar) a ~~> a -| GG[a][evar]

-------------------------- :: tvarr
GG |-pr (evar) a ~~> a -| GG

GG |-pr (evar) at1 ~~> at3 -| TT
TT |-pr (evar) [TT]at2 ~~> at4 -| DD
-------------------------- :: arrow
GG |-pr (evar) at1 -> at2 ~~> at3 -> at4 -| DD

-------------------------- :: evarL
GG[evarb][evar] |-pr (evar) evarb ~~> evarb -| GG[evarb][evar]

-------------------------- :: evarR
GG[evar][evarb] |-pr (evar) evarb ~~> evarb1 -| GG[evarb1,evar][evarb=evarb1]

defn

GG |-pr pm ( evar ) aA ~~> at -| DD ::  :: sprpromotion :: 'p_pr_'
{{ tex [[GG]] \vdash^{\!\![[pm]]}_{\!\![[evar]]} [[aA]] [[~~>]] [[at]] [[-|]] [[DD]] }}
by

GG[evarb,evar] |-pr- (evar) aA[a ~> evarb] ~~> at -| DD
-------------------------- :: forallL
GG[evar] |-pr- (evar) \/a. aA ~~> at -| DD

GG, a |-pr+ (evar) aA ~~> at -| DD, a
-------------------------- :: forallR
GG |-pr+ (evar) \/a. aA ~~> at -| DD

a notin fv(aA)
GG |-pr+ (evar) aA ~~> at -| DD
-------------------------- :: forallRR
GG |-pr+ (evar) \/a. aA ~~> at -| DD

GG |-pr (evar) at1 ~~> at2 -| DD
-------------------------- :: mono
GG |-pr pm (evar) at1 ~~> at2 -| DD

GG  |-pr -pm (evar) aA1 ~~> at1 -| TT
TT |-pr  pm (evar) [TT] aA2  ~~> at2 -| DD
-------------------------- :: arrow
GG |-pr pm (evar) aA1 -> aA2 ~~> at1 -> at2 -| DD


-------------------------- :: unknown
GG[evar] |-pr pm (evar) unknown ~~> evarb -| GG[evarb,evar]

-------------------------- :: unknownG
GG[evar] |-pr pm (evar) unknown ~~> gb -| GG[gb,evar]

defn

GG |-wf aA ::  :: wellformedness :: 'wf_'
{{ tex [[GG]] [[|-wf]] [[aA]] }}
by

-------------- :: int
GG |-wf int

GG |-wf at1
GG |-wf at2
--------------------- :: arrow
GG |-wf at1 -> at2

evar in GG
--------------------- :: evar
GG |-wf evar

defn

GG |-u at1 ~= at2 -| DD ::  :: unification :: 'u_'
{{ tex [[GG]] [[|-u]] [[at1]] [[~=]] [[at2]] [[-|]] [[DD]] }}
by

------------------ :: refl
GG |-u at ~= at -| GG

GG |-u at1 ~= at3 -| TT
TT |-u [TT]at2 ~= [TT]at4 -| DD
------------------ :: arrow
GG |-u at1 -> at2 ~= at3 -> at4 -| DD

GG |-pr (evar) at1 ~~> at2 -| DD[evar]
------------------ :: evarL
GG |-u evar ~= at1 -| DD[evar=at2]

GG |-pr (evar) at1 ~~> at2 -| DD[evar]
------------------ :: evarR
GG |-u at1 ~= evar -| DD[evar=at2]

defn

GG |-sub aA1 <: aA2 -| DD ::  :: subtyping :: 's_'
{{ tex [[GG]] [[|-sub]] [[aA1]] [[<:]] [[aA2]] [[-|]] [[DD]] }}
by


-------------------------- :: tvar
GG[a] |-sub a <: a -| GG[a]



-------------------------- :: evar
GG[evar] |-sub evar <: evar -| GG[evar]


-------------------- :: int
GG |-sub int <: int -| GG


GG |-sub aA3 <: aA1 -| TT
TT |-sub [TT] aA2 <: [TT] aA4 -| DD
----------------------------------------- :: arrow
GG |-sub aA1 -> aA2 <: aA3 -> aA4 -| DD


GG, a |-sub aA1 <: aA2 -| DD, a, TT
----------------------------- :: forallR
GG |-sub aA1 <: \/ a. aA2 -| DD


GG, mevar, evar |-sub aA1 [a ~> evar] <: aA2 -| DD, mevar, TT
------------------------------ :: forallL
GG |-sub \/ a. aA1 <: aA2 -| DD

GG[evar] |-pr + (evar) aA ~~> at -| DD[evar]
---------------------------------- :: instL
GG[evar] |-sub  evar <: aA -| DD[evar=at]

GG[evar] |-pr - (evar) aA ~~> at -| DD[evar]
---------------------------------- :: instR
GG[evar] |-sub  aA <: evar -| DD[evar=at]

GG[evar] |-pr + (evar) aA ~~> at -| DD1, evar, DD2
DD1 |-wf at
---------------------------------- :: instLL
GG[evar] |-sub  evar <: aA -| DD1, evar = at, DD2

GG[evar] |-pr - (evar) aA ~~> at -| DD1, evar, DD2
DD1 |-wf at
---------------------------------- :: instRR
GG[evar] |-sub  aA <: evar -| DD1, evar = at, DD2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Kind Inference
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
typing :: '' ::=

defn

EE |- dt ~> HH :: :: dt :: 'dt_'
{{tex [[EE]] \vdash^{\!\!\mathsf{dt} } [[dt]] \leadsto [[HH]] }}
by

% Haskell 98

(T : </ ki // i /> ---> star) in EE
</ EE , </ ai : ki // i /> |-dc T </ ai // i/>  dcj ~> tj // j />
---------------------------  :: decl
EE |- data T </ ai // i />    =  </ dcj // j />  ~> </ Dj: \/ </ ai :ki //i /> .tj //j />

% TYPEINTYPE

(T : \/i [ckvs1]. \/ [ckvs2]. </ eki // i/> ---> star ) in EE
</ EE, [ckvs1], [ckvs2], </ ai : eki // i /> |-dc (T @[ckvs1] @[ckvs2] </ ai // i />) dcj ~> eAj // j />
---------------------------  :: tt
EE |- data T </ ai // i /> =  </ dcj // j />  ~>  </ Dj:  \/i [ckvs1] . \/ [ckvs2] . \/ </ ai : eki // i /> . eAj // j />

% (T : \/i [ckvs1] . \/ [ckvs2] . </ eki // i /> ---> star ) in EE
% </ EE, [ ckvs1 ], [ckvs2], </ ai : eki // i />  |- et  dcj ~> eAj // j />
% -------------------------------------  :: tt
% EE |- data T </ ai // i /> =  </ dcj // j />  ~>  </ Dj:  \/i [ckvs1] . \/[ckvs2]. \/ </ ai : eki // i/> .  eAj // j />

defn

A : K |- kvs ~> ckvs -| A' ::  :: matching_tt :: 'mat_'
{{ tex [[A]] : [[K]] [[|-]] [[kvs]] \leadsto [[ckvs]] [[-|]] [[A']] }}

by

--------------------------- :: empty
et : star |- empty ~> empty -| et

(et1 a) : ek2 |- kvs  ~> ckvs -| et2
--------------------------- :: arr
et1 : ek1 -> ek2 |- a, kvs ~> a : ek1, ckvs -| et2

(et1 @ b) : eK |- kvs ~> ckvs -| et2
--------------------------- :: forall
et1 : (\/ b : ek1.  eK) |- kvs ~> b : ek1, ckvs -| et2

(et1 @ a) : eK |- kvs ~> ckvs -| et2
--------------------------- :: forallr
et1 : (\/ (a : ek1) ->  eK) |- a, kvs ~> a : ek1, ckvs -| et2


defn

rs K  ::  :: rs :: 'sr_' {{ tex \rceil [[K]] \lceil }}
by


------------------- :: star
rs star

rs k2
------------------- :: arrow
rs k1 -> k2

rs A
------------------- :: foralli
rs \/ a.  A

rs A
------------------- :: forall
rs \/ [kvs].  A

rs A
------------------- :: forall_infer
rs \/i [a].  A

rs A
------------------- :: foralli_infer
rs \/i [a:k].  A

defn

EE |-dc t dc ~> A :: :: dc :: 'dc_'
  {{tex [[EE]] [[|-dc]]_{\!\![[t]]} [[dc]] \leadsto [[A]]}}
by

EE |- </ ti // i /> ---> t : star
---------------------------  :: decl
EE |-dc t D </ ti // i /> ~> </ ti // i /> ---> t

% ikvs in Q ( </ Ai' // i/> )
% </ EE, [ikvs] |- Ai : star ~> Ai' // i />
% ---------------------------  :: poly
% EE |- t D </ Ai // i /> ~> \/i [ikvs] . </ Ai' // i /> ---> t


defn

EE ; HH |-p pgm : A :: :: pgm :: 'pgm_' by

% Haskell 98

% EE |- HH
EE' = EE,  </ Ti : ki // i />
</ EE' |- dti ~> HHi // i />
EE' ; HH, </ HHi // i /> |-p pgm : A
---------------------------------------  :: dt
EE ; HH |-p rec </ dti // i /> ; pgm : A

EE ; HH |- e : A
---------------------------- :: expr
EE ; HH |-p e : A

% TYPE IN TYPE

EE ; HH |- e : eA
---------------------------- :: expr_tt
EE ; HH |-p e : eA

% EE |- dtsig ~> T : eK
% EE, T : eK ; HH |-p pgm : A
% ---------------------------- :: sig
% EE ; HH |-p sig dtsig ; pgm : A

% (T : eK) in EE
% EE |- dt ~> HH1
% EE ; HH, HH1 |-p pgm : eA
% ---------------------------- :: dt_ttS
% EE ; HH |-p rec dt ; pgm : eA

defn

EE ; HH |- e : A :: :: kind_expr :: 'e_' by

defn

EE |- A : K :: :: kinding :: 'k_'
  {{ tex [[EE]] \vdash^{\!\!\mathsf{k} } [[A]] : [[K]] }}
by


--------------------------- :: star
EE |- star : star

--------------------------- :: nat
EE |- nat : star

(a : k) in EE
--------------------------- :: var
EE |- a : k

(T : k) in EE
---------------------------------- :: tcon
EE |- T : k

% --------------------------- :: arrow
% EE |- -> : star -> star -> star

EE , a : k |- A : star
--------------------------- :: forall
EE |- \/ a : k. A : star

EE , a : k |- A : K
--------------------------- :: gen
EE |- A : \/ a : k . K

EE , a : k |- A : star
--------------------------- :: forall_tt
EE |- \/ a . A : star

EE |- t2 : k1
EE |- t1 : k1 -> k2
--------------------------- :: app
EE |- t1 t2 : k2

EE , X |- A : star
--------------------------- :: kforall
EE |- \/ X . A  : star

EE |- A : \/ X . K
EE |- k
---------------------------------- :: inst
EE |- A : K [ X |-> k]

EE |- A : \/ a: k . K
EE |- k'
---------------------------------- :: inst_tt
EE |- A : K [ a |-> k']

defn

EE |- A <= K ~> A' :: :: kinding_checking :: 'kc_'
{{ tex [[EE]] \vdash^{\!\!\mathsf{kc} } [[A]] [[<=]] [[K]] \leadsto [[A']] }}
by


EE |- A : eK ~> eA1
EE |- eA1 : eK <: ek ~> eA2
------------------------ :: sub
EE |- A <= ek ~> eA2

defn

EE |- A : K ~> A' :: :: kinding_tt :: 'ktt_'
{{ tex [[EE]] \vdash^{\!\!\mathsf{k} } [[A]] : [[K]] \leadsto [[A']] }}
by


--------------------------- :: star
EE |- star : star ~> star

--------------------------- :: nat
EE |- nat : star ~> nat

(a : ek) in EE
--------------------------- :: var
EE |- a : ek ~> a

(T : eK) in EE
---------------------------------- :: tcon
EE |- T : eK ~> T

% --------------------------- :: arrow
% EE |- -> : star -> star -> star ~> ->

EE |- k <= star ~> ek
EE , a : ek |- A <= star ~> eA
--------------------------- :: forall
EE |- \/ a : k. A : star ~> \/ a : ek . eA

EE |- k <= star ~> ek
EE , a : ek |- A <= star ~> eA
--------------------------- :: forallr
EE |- \/ a : k -> A : star ~> \/ a : ek -> eA

EE |-el ek : star
EE , a : ek |- A <= star ~> eA
--------------------------- :: foralli
EE |- \/ a . A : star ~> \/ a : ek . eA

% EE |- t1 : eK1 ~> et1
% EE |- et1 : eK1 <: ek1 -> ek2 ~> et2
% EE |- t2 <= ek1 ~> et3
% --------------------------- :: app
% EE |- t1 t2 : ek2 ~> et2 et3

EE |- k1 : \/ a: ek . eK ~> et1
EE |- k2 <= ek ~> et2
---------------------------------- :: kapp
EE |- k1 @k2 : eK [ a |-> et2] ~> et1 @et2

EE |- k1 : \/i [</ ai: eki // i />] . \/ a: ek . eK ~> et1'
</ EE |-el eti : eki [ </  ai |-> eti  // i/> ] // i />
EE |- k2 <= ek [ </  ai |-> eti  // i/> ] ~> et2'
---------------------------------- :: kapp_infer
EE |- k1 @k2 : eK [ </  ai |-> eti  // i/> ] [ a |-> et2] ~> et1' @ [ </ eti // i />] @et2'


defn

EE |-el eA : eK :: :: ela_kinding :: 'ela_' by


--------------------------- :: star
EE |-el star : star

--------------------------- :: nat
EE |-el nat : star

(a : ek) in EE
--------------------------- :: var
EE |-el a : ek

(T : eK) in EE
---------------------------------- :: tcon
EE |-el T : eK

% --------------------------- :: arrow
% EE |-el -> : star -> star -> star

EE |-el ek : star
EE , a : ek |-el eA : star
--------------------------- :: forall
EE |-el \/ a : ek. eA : star

EE |-el ek : star
EE , a : ek |-el eA : star
--------------------------- :: forall_infer
EE |-el \/i [a : ek]  . eA : star

EE |-el et1 : ek1 -> ek2
EE |-el et2 : ek1
--------------------------- :: app
EE |-el et1 et2 : ek2

EE |-el et1 : \/ a:ek . eK
EE |-el et2 : ek
---------------------------------- :: kapp
EE |-el et1 @et2 : eK [ a |-> et2]

EE |-el et1 : \/i [a:ek] . eK
EE |-el et2 : ek
---------------------------------- :: kapp_infer
EE |-el et1 @et2 : eK [ a |-> et2]

defn

EE |- A : K |> A' : K1   ::  :: arrowing :: 'arrowing_'
by


------------------------------------ :: refl
EE |- et : ek1 -> ek2 |> et : ek1 -> ek2

EE |-el et2 : ek
EE |- et1 @et2 : eK [a |-> et2] |> et3 : ek2
------------------------------------ :: forall
EE |- et1 : \/ a:ek . eK |> et3 : ek2

EE |-el et2 : ek
EE |- et1 @et2 : eK [a |-> et2] |> et3 : ek2
------------------------------------ :: forall_infer
EE |- et1 : \/i [a:ek] . eK |> et3 : ek2

defn

EE |- ( A1 : K1 ) . ( A2 : K2 ) : K ~> A :: :: app_mode :: 'kapp_'
{{ tex [[EE]] \vdash^{\!\!\mathsf{kapp} } ([[A1]] : [[K1]]) \bullet ([[A2]]  : [[K2]]) : [[K]] \leadsto [[A]] }}

by

EE |- et2 : eK <: ek1 ~> et3
-------------------------------- :: arrow
EE |- ( et1 : ek1 -> ek2 ) . (et2 : eK) : ek2 ~> et1 et3

EE |-el et : ek
EE |- (et1 @ et : eK1 [ a |-> et]) . (et2 : eK2) : ek2 ~> et3
----------------------------------- :: forall
EE |- ( et1 : \/ a:ek. eK1 ) . (et2 : eK2) : ek2 ~> et3


defn
EE |- A : K1 <: K2 ~> A' ::  :: instantiation :: 'inst_'
{{ tex [[EE]] \vdash^{\!\!\mathsf{inst} } [[A]] : [[K1]] [[<:]] [[K2]] \leadsto [[A']] }}
by

------------------------ :: refl
EE |- eA : ek <: ek ~> eA

EE |-el et : ek1
EE |- eA1 @ et : eK [a |-> et] <: ek2 ~> eA2
---------------------------------- :: forall
EE |- eA1 : \/ a : ek1. eK <: ek2 ~> eA2

EE |-el et : ek1
EE |- eA1 @ et: eK [a |-> et] <: ek2 ~> eA2
---------------------------------- :: forall_infer
EE |- eA1 : \/i [a:ek1]. eK <: ek2 ~> eA2

defn

EE |- K :: :: kind_validate :: 'kv_' by

-------------- :: star
EE |- star

EE |- K1
EE |- K2
-------------- :: arrow
EE |- K1 -> K2

X in EE
-------------- :: kvar
EE |- X

EE, X |- K
-------------- :: forall
EE |- \/ X . K

EE, X |- K
-------------- :: foralli
EE |- \/i [ X ] . K

defn

EE ok :: :: well_formed_tctx :: 'tctx_'
 {{ tex [[EE]] \ \mathsf{ok} }} by

------------------------- :: empty
empty ok

EE ok
EE |-el et : star
------------------------- :: tvar_tt
EE , a : et ok

EE ok
EE |-el eK : star
------------------------- :: tcon_tt
EE , T : eK ok

defn

EE |- ckvs :: :: well_formed_kvs :: 'fkv_'
by

-------------- :: empty
EE |- empty

EE |-el et : star
EE , a : et |- ckvs
---------------------- :: cons
EE |- a : et , ckvs



defn

EE |- HH :: :: well_formed_ectx :: 'ectx_'
by

------------------------- :: empty
EE |- empty

EE |- HH
EE |- A : star
------------------------- :: var
EE  |- HH , x : A

EE |- HH
EE |- A : star
------------------------- :: dcon
EE  |- HH , D : A

EE |- HH
EE |-el eA : star
------------------------- :: var_tt
EE  |- HH , x : eA

EE |- HH
EE |-el eA : star
------------------------- :: dcon_tt
EE  |- HH , D : eA


% defn

% EE |- K1 <: K2 :: :: subkinding :: 'sub_'
% {{tex [[EE]] [[|-]] [[K1]] [[<:]] [[K2]] }}
% by

% ------------- :: refl
% EE |- K <: K

% EE, [kvs] |-  K1 <: K2
% ------------------------------ :: forall
% EE |-  K1 <:  \/i [kvs] .K2

% EE |- k
% EE |- K1 [ X |-> k] <: K2
% ------------------------------ :: inst
% EE |- \/i [X] . K1 <: K2

defn

EE |-gen ckvs HH1 ~> HH2 :: :: gen :: ''
{{ tex [[EE]] [[|-gen]]_{\!\![[ckvs]]} [[HH1]] \leadsto [[HH2]] }}

by

</ ckvs, ckvsi in Q (  eAi  ) // i />
-------------------------------------------- :: gen
EE |-gen ckvs </ Di :  eAi // i />  ~> </ Di :  \/i [ckvs, ckvsi] . eAi // i />

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGORITHMIC TYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
algo_typing :: 'a_' ::=

defn

DD ; GG ||-p pgm : A :: :: pgm :: 'pgm_'
by

% Haskell 98

TT1 = OO, [< </Xai // i /> >],  </ Ti : Xai // i />
</ TTi |- dti ~> TTssi ; GGi // i />
TTsn --->> OO'
OO' ; GG, </ GGi // i /> ||-p pgm : A
---------------------------------------  :: dt
OO ; GG ||-p rec </ dtti // i IN 1..n /> ; pgm : A

[OO] OO; [OO] GG |- e : A
---------------------------- :: expr
OO ; GG ||-p e : A


DD --->> OO
[OO] OO; [OO] GG |- e : A
---------------------------- :: expr_alt
DD ; GG ||-p e : A

% PolyKinds

[OO] OO; [OO] GG |- e : eA
---------------------------- :: expr_tt
OO ; GG ||-p e : eA

OO |- dtsig ~> T : eK
OO, T : eK ; GG ||-p pgm : eA
---------------------------- :: sig
OO ; GG ||-p sig dtsig ; pgm : eA

TT1 = OO, [< </ Xai : star // i /> >], </ Ti : Xai // i />
</ TTi |- dti ~> TTssi ; GGi // i />
</ xckvsi = unsolved ([TTsn] Xai) // i />
</ TTsn ||-gen ckvsi ([TTsn] (GGi[ </ xckvsi |-> ckvsi // i /> ])) ~> GG'i // i />
OO , </ Ti : \/i [ckvsi] . (([TTsn] Xai) [ </ xckvsi |-> ckvsi // i /> ]) // i /> ; GG , </ GG'i [</ Ti |-> Ti @ [ ckvsi ] // i />] // i /> ||-p pgm : eA
---------------------------------------  :: dt_tt
OO ; GG ||-p rec </ dtti // i IN 1..n /> ; pgm : eA

(T : eK) in OO
OO |- dt ~> OO ; GG1
OO ; GG , GG1 ||-p pgm : eA
---------------------------------------  :: dt_ttS
OO ; GG ||-p rec dt ; pgm : eA

defn

DD |- dt ~> TT ; GG :: :: dt :: 'dt_'
{{tex [[DD]] \Vdash^{\!\!\mathsf{dt} } [[dt]] \leadsto [[GG]] \dashv [[TT]] }}
by

% Haskell 98

% (T : k) in DD
% DD, </ Xai // i /> |- [DD]k ~ (</ Xai // i /> ---> star) -| TT1, </ Xai = ki // i />
% </ TTj, </ ai : ki // i /> |-T </ ai // i/>  dcj ~> tj -| TTsj, </ ai : ki // i /> // j />
% ---------------------------  :: decl
% DD |- data T </ ai // i />    =  </ dccj // j IN 1..n />  ~> TTsn ; </ Dj: \/ </ ai : ki //i /> .tj //j />

% (T : \/i [ckvs1]. \/ [ckvs2]. ek) in DD
% DD, marker T, [ckvs1], [ckvs2], </ Xai : star // i /> |- [DD]ek ~ (</ Xai // i /> ---> star) -| DD1
% TT1 = DD1, </ ai : Xai // i />
% </ TTj  |-(T @[ckvs1] @[ckvs2] </ ai // i />)  dcj ~> eAj -| TTsj // j />
% TTsn = TT, marker T, TT'
% ---------------------------  :: tt
% DD |- data T </ ai // i />    =  </ dccj // j IN 1..n />  ~> TT ; </ Dj: \/i [ckvs1] . \/ [ckvs2] . \/ </ ai :[TTsn]Xai //i /> .eAj // j />

(T : \/i [ckvs1]. \/ [ckvs2]. ek) in DD
DD, [ckvs1], [ckvs2], </ Xai : star // i /> |- [DD]ek ~= (</ Xai // i /> ---> star) -| TT1, [ckvs1], [ckvs2], </ Xai : star = eki // i />
</ TTj, [ckvs1], [ckvs2], </ ai : eki // i />  |-(T @[ckvs1] @[ckvs2] </ ai // i />)  dcj ~> eAj -| TTsj, [ckvs1], [ckvs2], </ ai : eki  // i /> // j />
---------------------------  :: tt
DD |- data T </ ai // i />    =  </ dccj // j IN 1..n />  ~> TTsn ; </ Dj: \/i [ckvs1] . \/ [ckvs2] . \/ </ ai : eki //i /> .eAj // j />

defn

DD |- t dc ~> A -| TT :: :: dc :: 'dc_'
  {{tex [[DD]] \Vdash^{\!\!\mathsf{dc} }_{\!\![[t]]} [[dc]] \leadsto [[A]] [[-|]] [[TT]]}}
by

% Haskell 98

DD |- </ ti // i /> ---> t : star -| TT
---------------------------  :: decl
DD |- t D </ ti // i /> ~> </ ti // i /> ---> t -| TT

% PolyKinds

</ DDi |- Ai : Ki ~> Ai' -| TTi // i IN 1..n />
</ TTi |- Ai' : [TTi] Ki <: star ~> Ai'' -| DDssi //i IN 1..n/>
---------------------------  :: poly
DD1 |- t D </ Ai // i IN 1..n /> ~> \/i [ikvs] . </ Ai'' // i IN 1..n /> ---> t -| DDsn

% TT


DD, marker D |- \/ kvs.  (</ ti // i /> ---> et) : star ~> eA -| TT1, marker D, TT2
xckvs = unsolved (TT2)
% ckvs = fresh (xckvs)
---------------------------  :: tt
DD |- et \/ kvs. D </ ti // i /> ~> \/i [ckvs] . (([TT2] eA)[ xckvs |-> ckvs ]) -| TT1

defn

DD |- A : K -| TT :: :: kinding :: 'k_'
  {{ tex [[DD]] \Vdash^{\!\!\mathsf{k} } [[A]] : [[K]] [[-|]] [[TT]] }}
by

--------------------------- :: nat
DD |- nat : star -| DD

(a : k) in DD
--------------------------- :: var
DD |- a : k -| DD

(T : k) in DD
---------------------------------- :: tcon
DD |- T : k -| DD

% --------------------------- :: arrow
% DD |- -> : star -> star -> star -| DD

DD |- k
DD, a : k |- A : k2 -| TT, a : k
[TT]k2 = star
--------------------------- :: forall
DD |- \/ a : k. A : star -| TT

DD |- t1 : k1 -| TT1
TT1 |- t2 : k2 -| TT2
TT2 |- [TT2]k1 . [TT2]k2 : k3 -| TT
-------------------------------- :: app
DD |- t1 t2 : k3 -| TT

defn

DD |- k1 . k2 : k' -| TT :: :: app_mode :: 'kapp_'
{{ tex [[DD]] \Vdash^{\!\!\mathsf{kapp} } [[k1]] \bullet [[k2]] : [[k']] [[-|]] [[TT]] }}
by


DD[Xa1, Xa2, Xa = Xa1 -> Xa2] |- Xa1 ~= k -| TT
-------------------------- :: kuvar
DD[Xa] |- Xa . k : Xa2 -| TT

DD |- k1 ~= k -| TT
---------------------- :: arrow
DD |- k1 -> k2 . k : k2 -| TT

defn

DD |- ( A1 : K1 ) . A2 : K' ~> A -| TT :: :: app_mode_poly :: 'kapp_tt_'
{{ tex [[DD]] \Vdash^{\!\!\mathsf{kapp} } ([[A1]] : [[K1]]) \bullet [[A2]] : [[K']] [[~>]] [[A]] [[-|]] [[TT]] }}
by

DD |- t <= ek1 ~> et2 -| TT
-------------------------------- :: arrow
DD |- ( et1 : ek1 -> ek2 ) . t : ek2 ~> et1 et2 -| TT

DD, Xa: ek1 |- (et1 @Xa : eK [ a |-> Xa]) . t : ek ~> et -| TT
----------------------------------- :: forall
DD |- ( et1 : \/ a:ek1. eK ) . t : ek ~> et -| TT

DD, Xa: ek1 |- (et1 @Xa : eK [ a |-> Xa]) . t : ek ~> et -| TT
----------------------------------- :: forall_infer
DD |- ( et1 : \/i [a:ek1]. eK ) . t : ek ~> et -| TT

DD1, Xa1:star,Xa2:star,Xa:ek=(Xa1->Xa2), DD2 |- t <= Xa1 ~> et2 -| TT
----------------------------------------------- :: kuvar
DD1, Xa:ek, DD2 |- (et1 : Xa) . t : Xa2 ~> et1 et2 -| TT


defn

DD |- K1 ~= K2 -| TT :: :: unif :: 'u_'
 {{ tex [[DD]] \Vdash^{\!\!\mathsf{u} } [[K1]] [[~=]] [[K2]] [[-|]] [[TT]] }}
by


----------------------- :: refl
DD |- k ~= k -| DD

----------------------- :: refl_tt
DD |- ek ~= ek -| DD


DD |- k1 ~= k3 -| TT1
TT1 |- [TT1] k2 ~= [TT1] k4 -| TT
--------------------------------- :: arrow
DD |- k1 -> k2 ~= k3 -> k4 -| TT

DD |-pr (Xa) k ~~> k2 -| TT[Xa]
------------------------------------------ :: kvarL
DD[Xa] |- Xa ~= k -| TT[Xa=k2]

DD |-pr (Xa) et1 ~~> et2 -| TT1, Xa:ek1, TT2
TT1 |-el et2 : ek2
TT1 |- [TT1] ek1 ~= ek2 -| TT3
------------------------------------------ :: kvarL_tt
DD |- Xa ~= et1 -| TT3, Xa : ek1 = et2, TT2

DD |-pr (Xa) et1 ~~> et2 -| TT1, Xa:ek1, TT2
TT1 |-el et2 : ek2
TT1 |- [TT1] ek1 ~= ek2 -| TT3
------------------------------------------ :: kvarR_tt
DD |- et1 ~= Xa  -| TT3, Xa : ek1 = et2, TT2


DD1, DD2 ++ Xa: ek1 -| TT
DD[{TT}] |-pr (Xa) et1 ~~> et2 -| TT1, { TT2, Xa : ek1,  TT3 } , TT4
TT1, {TT2} |-el et2 : ek2
TT1, {TT2} |- [TT1,TT2] ek1 ~= ek2 -| TT5, {TT6}
------------------------------------------------------- :: kvarL_lo_tt
DD[{DD1, Xa : ek1, DD2}] |- Xa ~= et1 -| TT5, {TT6,  Xa : ek1 = et2 , TT3 }, TT4

DD1, DD2 ++ Xa: ek1 -| TT
DD[{TT}] |-pr (Xa) et1 ~~> et2 -| TT1, { TT2, Xa : ek1,  TT3 } , TT4
TT1, {TT2} |-el et2 : ek2
TT1, {TT2} |- [TT1,TT2] ek1 ~= ek2 -| TT5, {TT6}
------------------------------------------------------- :: kvarR_lo_tt
DD[{DD1, Xa : ek1, DD2}] |- et1 ~= Xa -| TT5, {TT6,  Xa : ek1 = et2 , TT3 }, TT4


DD |-pr (Xa) k ~~> k2 -| TT[Xa]
------------------------------------------ :: kvarR
DD[Xa] |- k ~= Xa -| TT[Xa=k2]


DD |- et1 ~= et3 -| DD1
DD1 |- [DD1] et2 ~= [DD1] et4 -| TT
----------------------------------- :: app
DD |- et1 et2 ~= et3 et4 -| TT

DD |- et1 ~= et3 -| DD1
DD1 |- [DD1] et2 ~= [DD1] et4 -| TT
----------------------------------- :: kapp
DD |- et1 @et2 ~= et3 @et4 -| TT


defn

DD |-pr ( et ) ek1 ~~> ek2 -| TT :: :: promote :: 'pr_'
{{ tex [[DD]] [[|-pr]]_{\!\![[et]]} [[ek1]] [[~~>]] [[ek2]] [[-|]] [[TT]] }}
by

---------------------------------- :: star
DD |-pr (Xa) star ~~> star -| DD

DD |-pr (Xa) k1 ~~> k3 -| DD1
DD1 |-pr (Xa) [DD1]k2 ~~> k4 -| TT
---------------------------------- :: arrow
DD |-pr (Xa) k1 -> k2  ~~> k3 -> k4 -| TT

------------------------------ :: kuvarL
DD[Xb][Xa] |-pr (Xa) Xb ~~> Xb -| DD[Xb][Xa]

------------------------------ :: kuvarR
DD[Xa][Xb] |-pr (Xa) Xb ~~> Xb1 -| DD[Xb1,Xa][Xb=Xb1]

---------------------------------- :: nat
DD |-pr (Xa) nat ~~> nat -| DD

---------------------------------- :: tvar
DD[a][Xa] |-pr (Xa) a ~~> a -| DD[a][Xa]

% ---------------------------------- :: arr
% DD |-pr (Xa) -> ~~> -> -| DD

---------------------------------- :: tcon
DD[T][Xa] |-pr (Xa) T ~~> T -| DD[T][Xa]

DD |-pr (Xa) ek1 ~~> et1 -| DD1
DD1 |-pr (Xa) [DD1]ek2 ~~> et2 -| TT
---------------------------------- :: app
DD |-pr (Xa) ek1 ek2 ~~> et1 et2 -| TT

DD |-pr (Xa) ek1 ~~> et1 -| DD1
DD1 |-pr (Xa) [DD1]ek2 ~~> et2 -| TT
---------------------------------- :: kapp
DD |-pr (Xa) ek1 @ek2 ~~> et1 @et2 -| TT

------------------------------ :: kuvarL_tt
DD[Xb][Xa] |-pr (Xa) Xb ~~> Xb -| DD[Xb][Xa]

DD |-pr (Xa) [ DD ]et ~~> et1 -| TT[Xa][Xb:et]
------------------------------------------------ :: kuvarR_tt
DD[Xa ][Xb:et] |-pr (Xa) Xb ~~> Xb1 -| TT[Xb1 : et1, Xa][Xb:et = Xb1]

defn

DD |- K :: :: kind_validate :: 'kv_'
  {{ tex [[DD]] \Vdash^{\!\!\mathsf{kv} } [[K]] }}
by

-------------- :: star
DD |- star

DD |- k1
DD |- k2
-------------- :: arrow
DD |- k1 -> k2

Xa in DD
-------------- :: kuvar
DD |- Xa

defn

DD ok :: :: well_formed_tctx :: 'tctx_'
 {{ tex [[DD]] \ \mathsf{ok} }} by

------------------------- :: empty
empty ok

DD ok
DD |- k
------------------------- :: tvar
DD , a : k ok

DD ok
DD |- k
------------------------- :: tcon
DD , T : k ok

DD ok
------------------------- :: kuvar
DD , Xa ok

DD ok
DD |- k
------------------------- :: kuvarSolved
DD , Xa=k ok

DD ok
DD |-el ek : star
------------------------- :: kuvar_tt
DD , Xa : ek ok

DD ok
DD |-el ek2 : [DD]ek1
------------------------- :: kuvarSolved_tt
DD , Xa : ek1 = ek2 ok

DD ok
DD |-el ek : star
------------------------- :: tvar_tt
DD , a : ek ok

DD ok
DD |-el eK : star
------------------------- :: tcon_tt
DD , T : eK ok

DD, DDlo ok
------------------------- :: lo
DD , {DDlo} ok

DD ok
------------------------- :: marker
DD, marker D ok

defn

DD ||- GG :: :: well_formed_ectx :: 'ectx_'
  {{ tex [[DD]] \Vdash^{\!\!\mathsf{ectx} } [[GG]] }}
by

------------------------- :: empty
DD ||- empty

DD ||- GG
DD |- A <= star
------------------------- :: var
DD ||- GG , x : A

DD ||- GG
DD |- A <= star
------------------------- :: dcon
DD ||- GG , D : A

DD ||- GG
DD |-el eA : star
------------------------- :: var_tt
DD ||- GG , x : eA

DD ||- GG
DD |-el eA : star
------------------------- :: dcon_tt
DD ||- GG , D : eA



defn

DD --> TT :: :: tctx_extension :: 'ctxe_'
by

---------------------- :: empty
empty --> empty

DD --> TT
-------------------------- :: tvar
DD , a : k --> TT , a : k

DD --> TT
-------------------------- :: tvar_tt
DD , a : ek --> TT , a : ek

DD --> TT
-------------------------- :: tcon
DD , T : k --> TT , T : k

DD --> TT
-------------------------- :: tcon_tt
DD , T : eK --> TT , T : eK

DD --> TT
---------------------- :: kuvar
DD , Xa --> TT , Xa

DD --> TT
---------------------- :: kuvar_tt
DD , Xa : ek --> TT , Xa : ek

DD --> TT
[TT] k1 = [TT] k2
----------------------------- :: kuvarSolved
DD , Xa = k1 --> TT , Xa = k2

DD --> TT
[TT] et1 = [TT] et2
----------------------------- :: kuvarSolved_tt
DD , Xa : ek = et1 --> TT , Xa : ek = et2


DD --> TT
TT |- k
-------------------- :: solve
DD, Xa --> TT , Xa = k

DD --> TT
TT |-el et : [TT] ek
-------------------- :: solve_tt
DD, Xa : ek --> TT , Xa : ek = et

DD --> TT
-------------------- :: add
DD --> TT , Xa


DD --> TT
TT |-el ek : star
-------------------- :: add_tt
DD --> TT , Xa : ek

DD --> TT
TT |- k
-------------------- :: addSolved
DD --> TT , Xa = k

DD --> TT
TT |-el et : [TT] ek
-------------------- :: addSolved_tt
DD --> TT , Xa : ek = et

DD --> TT
--------------------------------- :: marker
DD , marker D --> TT , marker D

DD --> TT
DD, topo (DD1) --> TT, TT1
------------------------------------------------ :: lo
DD, {DD1} --> TT, {TT1}

% DD --> TT
% DDlo1 isperm DDlo2
% ------------------------------ :: lo
% DD, {DDlo1} --> TT, {DDlo2}

% DD, {DDlo1, DDlo2} --> TT, {TTlo1, TTlo2}
% TT, {TTlo1, TTlo2} |-el ek <= star
% ------------------------------------------------ :: lo_add
% DD, {DDlo1, DDlo2} --> TT, {TTlo1, Xa : ek, TTlo2}

% DD, {DDlo1, DDlo2} --> TT, {TTlo1, TTlo2}
% TT, {TTlo1, TTlo2} |-el et <= ek
% ------------------------------------------------ :: lo_addSolved
% DD, {DDlo1, DDlo2} --> TT, {TTlo1, Xa : ek = et, TTlo2}

% DD, {DDlo1, Xa : ek, DDlo2} --> TT, {TTlo1, Xa : ek, TTlo2}
% TT, {TTlo1, Xa : ek, TTlo2} |-el et <= ek
% topo (TTlo1, Xa : ek = et, TTlo2)
% ------------------------------------------------- :: lo_solve
% DD, {DDlo1, Xa : ek, DDlo2} --> TT, {TTlo1, Xa : ek = et, TTlo2}

% DD, {DDlo1, Xa : ek = et1, DDlo2} --> TT, {TTlo1, Xa : ek = et2, TTlo2}
% [TT, {TTlo1, Xa : ek = et2, TTlo2}] et1 = [TT, {TTlo1, Xa : ek = et2, TTlo2}] et2
% topo (TT, {TTlo1, Xa : ek = et2, TTlo2})
% ------------------------------------------------- :: lo_solved
% DD, {DDlo1, Xa : ek = et1, DDlo2} --> TT, {TTlo1, Xa : ek = et2, TTlo2}

defn

DD --->> OO :: :: tctx_extension_default :: 'ctxde_'
by

---------------------- :: empty
empty --->> empty

DD --->> OO
-------------------------- :: tvar
DD , a : k --->> OO , a : k

DD --->> OO
-------------------------- :: tcon
DD , T : k --->> OO , T : k

DD --->> OO
----------------------------- :: kuvarSolved
DD , Xa = k --->> OO , Xa = k


DD --->> OO
-------------------- :: solve
DD, Xa --->> OO , Xa = star


defn
DD ; A : K |- kvs ~> ckvs ; A' -| TT ::  :: matching_tt :: 'mat_'
{{ tex [[DD]] \mid [[A]] : [[K]] [[|-]] [[kvs]] [[~>]] [[ckvs]] [[-|]] [[A']] \mid [[TT]]  }}
by

------------------------------------------ :: empty
DD ; et : star |- empty ~> empty ; et -| DD

DD ; (et1 a) : ek2 |- kvs ~> ckvs ; et2 -| TT
------------------------------------ :: arr
DD ; et1 : ek1 -> ek2 |- a, kvs ~> a : ek1, ckvs ; et2 -| TT

DD ; (et1 @a) : eK |- kvs ~> ckvs ; et2 -| TT
------------------------------------ :: forall
DD ; et1 : \/ a : ek1.  eK |- kvs ~> a : ek1, ckvs ; et2 -| TT

------------------------------------------------------- :: kvarempty
DD[Xa : star] ; et : Xa |- empty ~> empty ; et -| DD[Xa : star = star]

DD [ Xa1 : star, Xa2 : star, Xa : star = Xa1 -> Xa2 ] ; (et1 a) : Xa2 |- kvs ~> ckvs ; et2 -| TT
-------------------------------------------------------------- :: kvarcons
DD [ Xa :star ] ; et1 : Xa |- a, kvs ~> a : Xa1, ckvs ; et2 -| TT

defn

DD |- A <= k  :: :: kinding_kc_eq :: 'kc_'
{{ tex [[DD]] \Vdash^{\!\!\mathsf{kc} } [[A]] [[<=]] [[k]] }}

by

DD |- A : k1 -| DD
[DD]k1 = [DD]k2
------------------------ :: eq
DD |- A <= k2


defn

DD |- A <= K ~> A' -| TT :: :: kinding_checking :: 'kc_'
{{ tex [[DD]] \Vdash^{\!\!\mathsf{kc} } [[A]] [[<=]] [[K]] [[~>]] [[A']] [[-|]] [[TT]] }}

by

DD |- A : eK ~> eA1 -| DD1
DD1 |- eA1 : [DD1] eK <: [DD1] ek ~> eA2 -| DD2
------------------------ :: sub
DD |- A <= ek ~> eA2 -| DD2

defn

DD |- dtsig ~> DD'  ::  :: sig :: 'sig_'
{{ tex [[DD]] \Vdash^{\!\!\mathsf{sig} } [[dtsig]] [[~>]] [[DD']] }}
by

ikvs = LS (K)
---------------------------- :: poly
OO |- data T : K ~> T : \/i [ikvs]. K


rs A
</ ai // i /> = LS (A)
OO , { </ Xai : star , ai : Xai // i/> } |- A : star ~> eK -| DD
ckvs1 = SS ( </ ai : [DD] Xai // i />  )
xckvs2 = unsolved (DD)
DD `-> </ ai // i />
---------------------------------------------- :: tt
OO |- data T : A ~> T : \/i [ckvs2] . ((\/i [ckvs1] . [DD] eK)[xckvs2 |-> ckvs2])

defn

DD |- A : K1 <: K2 ~> A' -| TT :: :: instantiation :: 'inst_'
{{ tex [[DD]] \Vdash^{\!\!\mathsf{inst} } [[A]] : [[K1]] [[<:]] [[K2]] [[~>]] [[A']] [[-|]] [[TT]] }}
by

DD |- ek1 ~= ek2 -| TT
---------------------- :: refl
DD |- eA : ek1 <: ek2 ~> eA -| TT

DD, Xa:ek1 |- eA1 @Xa : eK [a |-> Xa] <: ek2 ~> eA2 -| TT
------------------------------------------ :: forall
DD |- eA1 : \/ a:ek1 . eK <: ek2 ~> eA2 -| TT

DD, Xa:ek1 |- eA1 @Xa : eK [a |-> Xa] <: ek2 ~> eA2 -| TT
------------------------------------------ :: forall_infer
DD |- eA1 : \/i [a:ek1] . eK <: ek2 ~> eA2 -| TT



defn

DD |- A : K ~> K' -| TT :: :: kinding_tt :: 'ktt_'
{{ tex [[DD]] \Vdash^{\!\!\mathsf{k} } [[A]] : [[K]] [[~>]] [[K']] [[-|]] [[TT]] }}
by


--------------------------------- :: star
DD |- star : star ~> star -| DD

--------------------------- :: nat
DD |- nat : star ~> nat -| DD

(a : ek) in DD
--------------------------- :: var
DD |- a : ek ~> a -| DD

(T : eK) in DD
---------------------------------- :: tcon
DD |- T : eK ~> T -| DD

% --------------------------- :: arrow
% DD |- -> : star -> star -> star ~> -> -| DD

DD |- k <= star ~> ek -| DD1
DD1 , a : ek |- A <= star ~> eA -| DD2, a : ek, DD3
DD3 `-> a
------------------------------------------ :: forall
DD |- \/ a : k. A : star ~> \/ a : ek . [DD3] eA -| DD2, unsolved (DD3)

DD, Xa : star, a : Xa |- A <= star ~> eA -| DD2, a : Xa, DD3
DD3 `-> a
------------------------------------------ :: foralli
DD |- \/ a . A : star ~> \/ a : Xa . [DD3]eA -| DD2, unsolved (DD3)

DD |- t1 : eK1 ~> et1 -| DD1
DD1 |- (et1 : [DD1]eK1) . t2 : ek ~> et -| TT
------------------------------------ :: app
DD |- t1 t2 : ek ~> et -| TT

DD |- t1 : eK ~> et1 -| DD1
[DD1] eK = \/ a : ek . eK2
DD1 |- t2 <= ek ~> et2 -| DD2
---------------------------------------------- :: kapp
DD |- t1 @t2 : eK2 [a |-> et2] ~> et1 @et2 -| DD2

DD |- t1 : eK ~> et1 -| DD1
[DD1] eK = \/i [</ ai: eki // i />] . \/ a : ek . eK2
DD1, </ Xai : eki [ </ ai |-> Xai // i/> ] // i /> |- t2 <= ek [ </ ai |-> Xai // i/> ]~> et2 -| DD2
---------------------------------------------- :: kapp_infer
DD |- t1 @t2 : eK2[ </ ai |-> Xai // i/> ] [a |-> et2] ~> et1 @[</Xai // i/>] @et2 -| DD2

DD , X |- A : star ~> A' -| TT
--------------------------- :: kforall
DD |- \/ X . A  : star ~> \/ X. A' -| TT

DD , X |- A : star ~> A' -| TT
--------------------------- :: kforall_infer
DD |- \/i [X] . A  : star ~> \/i [X]. A' -| TT

defn

DD |-el eA : eK  :: :: ela_kinding :: 'ela_'
{{ tex [[DD]] \Vdash^{\!\!\mathsf{ela} } [[eA]] : [[eK]] }}
by


(Xa : ek) in DD
--------------------------------- :: kuvar
DD |-el Xa : [DD] ek

--------------------------------- :: star
DD |-el star : star

--------------------------- :: nat
DD |-el nat : star

(a : ek) in DD
--------------------------- :: var
DD |-el a : [DD] ek

(T : eK) in DD
---------------------------------- :: tcon
DD |-el T : [DD] eK

% --------------------------- :: arrow
% DD |-el -> : star -> star -> star

DD |-el ek : star
DD , a : ek |-el eA : star
------------------------------------------ :: forall
DD |-el \/ a : ek. eA : star

DD |-el ek : star
DD , a : ek |-el eA : star
------------------------------------------ :: forall_infer
DD |-el \/i [a : ek]. eA : star

DD |-el et1 : ek1 -> ek2
DD |-el et2 : ek1
------------------------------------ :: app
DD |-el et1 et2 : ek2

DD |-el et1 : \/ a : ek . eK
DD |-el et2 : ek
------------------------------------ :: kapp
DD |-el et1 @et2 : eK [a |-> [DD]et2]

DD |-el et1 : \/i [a : ek] . eK
DD |-el et2 : ek
------------------------------------ :: kapp_infer
DD |-el et1 @et2 : eK [a |-> [DD]et2]

defn

DD |- A : K |> A' : K1 -| TT   ::  :: arrowing :: 'arrowing_'
by


------------------------------------ :: refl
DD |- et : ek1 -> ek2 |> et : ek1 -> ek2 -| DD

DD, Xa:ek1 |- et1 @Xa : eK [a |-> Xa] |> et2 : ek2 -| TT
------------------------------------ :: forall
DD |- et1 : \/ a:ek1 . eK |> et2 : ek2 -| TT

DD, Xa:ek1 |- et1 @Xa : eK [a |-> Xa] |> et2 : ek2 -| TT
------------------------------------ :: forall_infer
DD |- et1 : \/i [a:ek1] . eK |> et2 : ek2 -| TT

DD1 |- [DD1] k ~= star -| TT1
------------------------------------ :: kuvar
DD1, Xa:k, DD2 |- et : Xa |> et : Xa1 -> Xa2 -| TT1, Xa1:star,Xa2:star,Xa:k=Xa1 ->  Xa2, DD2


defn

DD `-> kvs   ::  :: qcheck :: 'qc_' by

---------------------- :: empty
empty `-> kvs

DD `-> kvs
--------------------------- :: kuvarSolved
DD, Xa : ek1 = ek2  `-> kvs


DD `-> kvs
fkv([DD] ek) # kvs
--------------------------- :: kuvar
DD, Xa : ek  `-> kvs

DD `-> kvs
--------------------------- :: tvar
DD, a : ek `-> kvs

DD `-> kvs
--------------------------- :: tcon
DD, T : eK `-> kvs

DD, DDlo `-> kvs
--------------------------- :: lo
DD, {DDlo} `-> kvs

defn

TT1 ++ DD -| TT2    ::  :: moving :: 'mv_'
 {{ tex [[TT1]] [[++]] [[DD]] \leadsto [[TT2]] }}
by

--------------------------- :: empty
empty ++ DD -| DD


var(ek) # dom (DD2)
DD1 ++ DD2 -| TT
--------------------------- :: kuvar
Xa : ek , DD1  ++ DD2 -| Xa : ek, TT

var(ek) # dom (DD2)
DD1 ++ DD2 -| TT
--------------------------- :: tvar
a : ek , DD1 ++ DD2 -| a : ek , TT

NOT (var(ek) # dom (DD2))
DD1 ++ DD2, Xa : ek -| TT
--------------------------- :: kuvarM
Xa : ek , DD1  ++ DD -| TT

NOT (var(ek) # dom (DD2))
DD1 ++ DD2, a : ek -| TT
--------------------------- :: tvarM
a : ek , DD1 ++ DD2 -| TT


defn

DD ||-gen ckvs GG1 ~> GG2  :: :: agen :: ''
{{ tex [[DD]] [[||-gen]]_{\!\![[ckvs]]} [[GG1]] [[~>]] [[GG2]] }}

by

</ xckvsi = unsolved (eAi) // i />
-------------------------------- :: gen
DD ||-gen ckvs </ Di : eAi // i /> ~> </ D : \/i [ckvs] . \/i [ckvsi] . (eA [ xckvsi |-> ckvsi ]) // i />
