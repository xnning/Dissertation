metavar typvar, a {{ tex a }}, b {{tex b}}, L ::=
metavar kindvar, Xa {{ tex \widehat{\alpha} }}, Xb {{ tex \widehat{\beta} }} ::=

metavar expvar, x, y, f, g, m, nn {{ tex n }}, c, xs, fix {{ tex \mathsf{fix} }}, len, l ::=

indexvar index, i, j, n, m ::=

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL TYPE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

% Types

mode :: 'mode_' ::=
  | =>       ::  :: infer {{ tex \Rightarrow }}
  | <=       ::  :: check {{ tex \Leftarrow }}

varset, avs  :: 'varset_' ::=
  | a                        ::  :: a
  | x                        ::  :: x {{ tex x }}
  | avs1 , .. , avs2         ::  :: append
  | fv ( dd )                ::  :: fv_dd
  | fv ( GG )                ::  :: fv_gg
  | fv ( A )                 ::  :: fv_A
  | fv ( ef )                ::  :: fv_ef
  | avs set                  ::  :: a_set {{ tex \overbar{[[avs]]} }}
  | avs1 - avs2              ::  :: minus {{ tex [[avs1]] - [[avs2]] }}

dtyp, A {{tex \sigma}}, B {{tex \sigma_2}}, C {{tex \sigma_3}}, D {{tex \sigma_4}} :: 'dtyp_' ::=
  | int            ::   :: int
  | nat            ::   :: nat
  | natu           ::   :: natu {{ tex \mathsf{Nat}_\unknown }}
  | float          ::   :: float
  | bool           ::   :: bool
  | boolu          ::   :: boolu {{ tex \mathsf{Bool}_\unknown }}
  | a              ::   :: tvar
  | A -> B         ::   :: arrow
  | \/ varset . A  ::   :: all
  | \/ varset . t  ::   :: all_mono
  | mu a . A       ::   :: mu {{ tex \mu [[a]] [[.]] [[A]] }}
  | unknown        ::   :: unknown
  | question       ::   :: question
  | static         ::   :: static
  | gradual        ::   :: gradual
  | List A         ::   :: list
  | Listu A        ::   :: listu
  | A [ </  Ai ~> Bi // i /> ]  :: M :: subst
  | [ OO ] aA      :: S :: ctx_subst
  | [ OO ] A       :: S :: ctx_subst2
  | ( A )          :: S :: parens
  | r @ ( A )      :: S :: red   {{ tex {\color{red} [[A]] } }}
  | b @ ( A )      :: S :: blue {{ tex {\color{blue} [[A]] } }}
  | o @ ( A )      :: S :: orange {{ tex {\color{orange} [[A]] } }}
  | r @ \/ a . A   :: S :: red_all {{ tex [[\/]] {\color{red} [[a]]} . [[A]] }}
  | b @ \/ a . A   :: S :: blue_all {{ tex [[\/]] {\color{blue} [[a]]} . [[A]] }}
  | S ( A )        :: S :: subst2
  | ss -> A        ::   :: sctx_type
  | ( A , B )      ::   :: pair
  | [ l1 : A1 , .. , ln : An  ]  ::   :: record

% Mono Types

dtyp_mono, t {{ tex \tau }}, s {{ tex \tau }} :: 'dtyp_mono_' ::=
  | int       ::   :: int
  | a         ::   :: tvar
  | t -> s    ::   :: arrow
  | static    ::   :: static
  | gradual   ::   :: gradual
  | t [ </  ti ~>  si // i /> ]  :: M :: subst

% Castable Mono Types

dtyp_mono_cast, tc {{ tex t }} :: 'dtyp_mono_cast_' ::=
  | int        :: :: int
  | a          :: :: tvar
  | tc1 -> tc2 :: :: arrow
  | gradual    :: :: gradual

% Castable Types

dtyp_castable, gc  {{ tex \mathbb{C} }}  :: 'dtyp_castable_' ::=
  | int        :: :: int
  | a          :: :: tvar
  | gc1 -> gc2 :: :: arrow
  | \/ varset . gc  :: :: all
  | unknown    :: :: unknown
  | gradual    :: :: gradual


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO TYPE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Existential variable

evar {{ tex \widehat{a} }}, evarb {{ tex \widehat{b} }} :: 'evar_' ::=
  | sa :: :: evar {{ tex \widehat{a}_{S} }}
  | ga :: :: gevar {{ tex \widehat{a}_{G} }}
  | sb :: :: evarb {{ tex \widehat{b}_{S} }}
  | gb :: :: gevarb {{ tex \widehat{b}_{G} }}
  | Xa :: :: xa


% marker
ma :: 'ma_' ::=
  | mevar :: :: mevar   {{ tex \blacktriangleright_{ \widehat{a} } }}
  | mevarb :: :: mevarb   {{ tex \blacktriangleright_{ \widehat{b} } }}
  | msa :: :: msa  {{ tex \blacktriangleright_{ \widehat{a}_S } }}
  | msb :: :: msb  {{ tex \blacktriangleright_{ \widehat{b}_S } }}


% Types

atyp, aA {{ tex \sigma }}, aB, aC  :: 'atyp_' ::=
  | int            ::   :: int
  | a              ::   :: tvar
  | evar           ::   :: evar
  | aA1 -> aA2     ::   :: arrow
  | \/ a . aA      ::   :: all
  | unknown        ::   :: unknown
  | static         ::   :: static
  | gradual        ::   :: gradual
  | aA [ a ~> at ] :: M :: subst
  | [ GG ] aA      :: S :: ctx_subst
  | ( aA )         :: S :: parens

% Static Types

atyp_static, aT {{ tex T }} :: 'atyp_static_' ::=
  | int        ::   :: int
  | a          ::   :: tvar
  | evar       ::   :: evar
  | aT1 -> aT2 ::   :: arrow
  | \/ a . aT  ::   :: all
  | static     ::   :: static
  | gradual    ::   :: gradual
  | [ GG ] aA  :: S :: ctx_subst

% Mono Types

atyp_mono, at {{ tex \tau }}, as {{ tex \sigma }} :: 'atyp_mono_' ::=
  | int       ::   :: int
  | a         ::   :: tvar
  | evar      ::   :: evar
  | at -> as  ::   :: arrow
  | static    ::   :: static
  | gradual   ::   :: gradual
  | [ GG ] aA :: S :: ctx_subst

% Castable Mono Types

atyp_mono_cast, atc {{ tex t }} :: 'atyp_mono_cast_' ::=
  | int          :: :: int
  | a            :: :: tvar
  | evar         :: :: evar
  | atc1 -> atc2 :: :: arrow
  | gradual      :: :: gradual

% Castable Types

atyp_castable, agc  {{ tex \mathbb{C} }}  :: 'atyp_castable_' ::=
  | int          :: :: int
  | a            :: :: tvar
  | evar         :: :: evar
  | agc1 -> agc2 :: :: arrow
  | \/ a . agc   :: :: all
  | unknown      :: :: unknown
  | gradual      :: :: gradual

% Static Castable Types
atyp_scastable, asc {{ tex \mathbb{S} }} :: 'atyp_scastable_' ::=
  | int          :: :: int
  | a            :: :: tvar
  | evar         :: :: evar
  | asc1 -> asc2 :: :: arrow
  | \/ a . asc   :: :: all
  | gradual      :: :: gradual




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL EXPR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

dexp, e :: 'dtrm_' ::=
  | 1                ::   :: one
  | 2                ::   :: two
  | x                ::   :: var
  | id               ::   :: id {{ tex \mathsf{id} }}
  | n                ::   :: lit
  | cons             ::   :: cons
  | consu             ::   :: consu
  | nil              ::   :: nilu
  | nilu              ::   :: nil
  | zerou            :: :: zero {{ tex \mathsf{zero}_\unknown }}
  | succu            :: :: succu {{ tex \mathsf{succ}_\unknown }}
  | trueu            :: :: trueu {{ tex \mathsf{true}_\unknown }}
  | fold [ A ]       ::   :: fold  {{ tex [[fold]]_{[[A]]} }}
  | unfold [ A ]       ::   :: unfold  {{ tex [[unfold]]_{[[A]]} }}
  | \ x . e          ::   :: abs
  | \ x : A . e      ::   :: absan
  | e1 e2            ::   :: app
  | let x = e1 in e2 ::   :: let
  | let x : A = e1 in e2 ::   :: letann
  | ( e )            :: S :: paren
  | e : A            :: S :: anno
  | ( e1 , e2 )      ::   :: pair
  | 'a'              ::   :: a
  | fst              ::   :: fst
  | snd              ::   :: snd
  | e1 + e2          ::   :: plus


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO EXPR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

aexp, ae {{ tex e }} :: 'atrm_' ::=
  | x                  ::   :: var
  | n                  ::   :: lit
  | \ x . ae           ::   :: abs
  | \ x : aA . ae      ::   :: absan
  | ae1 ae2            ::   :: app
  | ae : aA            ::   :: anno
  | let x = ae1 in ae2 ::   :: let
  | ( ae )             :: S :: paren



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL CONTEXT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

dctx, dd {{ tex \Psi}} :: 'dctx_' ::=
  | empty       ::   :: empty
  | dd , x : A  ::   :: cons_var
  | dd , a      ::   :: cons_tvar
  | [ OO ] DD     :: S :: ctx_subst

sctx, ss {{ tex \Sigma }} :: 'sctx_' ::=
  | empty       ::   :: empty
  | A           ::   :: singleton
  | ss1 , ss2   ::   :: append


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO CONTEXT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

actx, GG {{ tex \Gamma}}, DD {{ tex \Delta }}, TT  {{ tex \Theta }}, OO {{ tex \Omega }}, DL {{ tex \Delta_L }}, DR {{ tex \Delta_R }}, GL {{ tex \Gamma_L }}, GR {{ tex \Gamma_R }}, GM {{ tex \Gamma_M }}, OL {{ tex \Omega_L }} , OR {{ tex \Omega_R }} :: 'actx_' ::=
  | empty                                          ::   :: empty
  | GG , x : aA                                    ::   :: cons_var
  | GG , a                                         ::   :: cons_tvar
  | GG , ma                                        ::   :: cons_mark
  | GG , evar                                      ::   :: cons_evar
  | GG , evar = at                                 ::   :: cons_evar_solu
  | GG [ a ]                                       :: S :: ctx_tvar
  | GG [ evar ]                                    :: S :: ctx_etvar
  | GG [ GG1 ]                                     :: S :: ctx_ctx
  | GG [ evar1 , evar2 ]                           :: S :: ctx_etvar2
  | GG [ evar1 , evar2 , evar3 ]                   :: S :: ctx_etvar3
  | GG [ evar = at ]                               :: S :: ctx_etvar_solve
  | GG [ evar1 , evar2 = at ]                      :: S :: ctx_etvar_solve2
  | GG [ evar1 , evar2 , evar3 = at ]              :: S :: ctx_etvar_solve3
  | GG [ evar1 = at1 , evar2 = at2 , evar3 = at3 ] :: S :: ctx_etvar_solve4
  | GG , a , DD                                    :: S :: middle
  | GG , x : aA , DD                               :: S :: middle2
  | GG , evar , DD                                 :: S :: middle3
  | GG , evar = at , DD                            :: S :: middle4
  | GG , DD                                        :: S :: ext
  | ( GG )                                         :: S :: parens
  | [ aA ] GG                                      :: S :: subst_ctx {{ tex  \mathsf{contaminate}( [[GG]] , [[aA]] ) }}
  | | GG |                                         :: S :: solve_ctx
  | evar    :: S :: singleton


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% F EXPR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fexp, es {{tex s}}, ef {{tex f}} :: 'ftrm_' ::=
  | 1              ::   :: one
  | x              ::   :: var
  | n              ::   :: lit
  | \ x : A . es   ::   :: absann
  | \ x . es       ::   :: abs
  | /\ avs . es    ::   :: tabs
  | es A           ::   :: tapp
  | es1 es2        ::   :: app
  | ( es )         :: S :: paren
  | | es |         ::   :: erase

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PBC EXPR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pexp, pe {{ tex s }}, rpe {{ tex r }}, CC {{ tex \mathcal{C} }} :: 'ptrm_' ::=
  | 1              ::   :: one
  | x              ::   :: var
  | n              ::   :: lit
  | \ x : A . pe   ::   :: absann
  | pe1 pe2        ::   :: app
  | /\ a . pe      ::   :: tabs
  | < A `-> B > pe ::   :: cast
  | ( pe )         :: S :: paren
  | S ( pe )       :: S :: subst

pvalue, pv {{ tex v }} :: 'pvalue_' ::=
  | n              ::   :: lit
  | \ x : A . pe   ::   :: absann
  | /\ a . pe      ::   :: tabs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TERMINALS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

terminals :: 'terminals_' ::=
  | ok      :: :: ok {{ tex \mathsf{ok} }}
  | ~       :: :: consist {{ tex \sim }}
  | ->      :: :: arrow   {{ tex \rightarrow }}
  | let     :: :: let     {{ tex \mathbf{let} }}
  | fst     :: :: fst     {{ tex \mathbf{fst} }}
  | snd     :: :: snd     {{ tex \mathbf{snd} }}
  | int     :: :: int     {{ tex \mathsf{Int} }}
  | nat     :: :: nat     {{ tex \mathsf{Nat} }}
  | bool     :: :: bool     {{ tex \mathsf{Bool} }}
  | float     :: :: float     {{ tex \mathsf{Float} }}
  | notin    ::  :: notin {{ tex \notin       }}
  | fv       ::  :: fv {{ tex \textsc{fv}  }}
  | List     ::  :: list  {{ tex \mathsf{List} }}
  | Listu    ::  :: listu {{ tex \mathsf{List}_\unknown }}
  | n       :: :: lit     {{ tex \mathsf{n} }}
  | cons       :: :: cons     {{ tex \mathsf{cons} }}
  | consu       :: :: consu     {{ tex \mathsf{cons}_\unknown }}
  | nil       :: :: nil     {{ tex \mathsf{nil} }}
  | nilu       :: :: nilu     {{ tex \mathsf{nil}_\unknown }}
  | fold      :: :: fold   {{ tex \mathbf{fold} }}
  | unfold      :: :: unfold   {{ tex \mathbf{unfold} }}
  | .       :: :: dot     {{ tex .\, }}
  | unknown :: :: unknown {{ tex \star }}
  | question ::  :: question {{ tex \mathit{?} }}
  | empty   :: :: empty   {{ tex \bullet }}
  | |-      :: :: turnstile {{ tex \vdash }}
  | |-OL    :: :: turnstile1 {{ tex \vdash^\mathit{OL} }}
  | |-HM    :: :: turnstile2 {{ tex \vdash^\mathit{HM} }}
  | |-DK    :: :: turnstile3 {{ tex \vdash^\mathit{DK} }}
  | |-AP    :: :: turnstile4 {{ tex \vdash^\mathit{AP} }}
  | |-F     :: :: turnstileF {{ tex \vdash^\mathit{F} }}
  | |-G     :: :: turnstileG {{ tex \vdash^\mathit{G} }}
  | -|      :: :: dashv {{ tex \dashv }}
  | ~>      :: :: mapsto    {{ tex \mapsto }}
  | <~      :: :: conssub   {{ tex \lesssim }}
  | <~~     :: :: inst   {{ tex \lessapprox }}
  | \       :: :: lambda    {{ tex \lambda }}
  | ~~>     :: :: translate {{ tex \rightsquigarrow }}
  | /\      :: :: tlambda   {{ tex \Lambda }}
  | \/      :: :: forall   {{ tex \forall }}
  | `->     :: :: cast      {{ tex \hookrightarrow }}
  | <       :: :: lbr  {{ tex \langle }}
  | >       :: :: rbr  {{ tex \rangle }}
  | static  :: :: sta {{ tex \mathcal{S} }}
  | gradual :: :: gra {{ tex \mathcal{G} }}
  | |>      :: :: match {{ tex \triangleright  }}
  | =>      :: :: inf   {{ tex \Rightarrow }}
  | <=      :: :: chk   {{ tex \Leftarrow }}
  | =>=>    :: :: application {{ tex \Rightarrow\!\!\!\!\Rightarrow }}
  | -->     :: :: ext   {{ tex \longrightarrow }}
  | S       :: :: psubst {{ tex \psubst }}
  | blame   :: :: blame  {{ tex \mathsf{blame} }}
  | ==>     :: :: reduce {{ tex \Downarrow }}
  | <:      :: :: subtype {{ tex <: }}
  | =nid    :: :: etaid {{ tex =_{\eta id} }}


formula :: formula_ ::=
  | judgement             :: :: judgement
  | formula1 .. formulan            ::   :: dots
  | dd |- e => A          :: :: ap_inf_introduction
  | dd ; ss |- e => A     :: :: ap_app_introduction
  | |- A1 <: A2           :: :: ap_sub_introduction
  | ss |- A1 <: A2        :: :: ap_sub_introduction2
  | dd |-AP e => A        :: :: ap_inf_no_trans
  | dd ; ss |-AP e => A   :: :: ap_app_no_trans
  | |-AP A1 <: A2         :: :: ap_sub_no_trans
  | ss |-AP A1 <: A2      :: :: ap_app_sub_no_trans
  | a in dd               :: :: bind_tvar {{ tex [[a]] \in [[dd]] }}
  | r @ ( a ) in dd       :: :: bind_red_tvar {{ tex {\color{red} [[a]] } \in [[dd]] }}
  | b @ ( a ) in dd       :: :: bind_blue_tvar {{ tex {\color{blue} [[a]] } \in [[dd]] }}
  | a in GG               :: :: bind_tvar2 {{ tex [[a]] \in [[GG]] }}
  | ( x : A ) in dd       :: :: bind_var {{ tex ( [[x]] : [[A]] ) \in [[dd]] }}
  | ( x : aA ) in GG      :: :: bind_var2 {{ tex ( [[x]] : [[aA]] ) \in [[GG]] }}
  | evar in fv ( aA )     :: :: fv {{ tex [[evar]] \in \textsc{fv} ( [[aA]] ) }}
  | evar notin fv ( aA )  :: :: nfv {{ tex [[evar]] \notin \textsc{fv} ( [[aA]] ) }}
  | evar notin fv ( GG )  :: :: dfv {{ tex [[evar]] \notin \textsc{fv} ( [[GG]] ) }}
  | varset1 notin varset2     :: :: notin_varset
  | ma notin fv ( GG )     :: :: mafv {{ tex [[ma]] \notin \textsc{fv} ( [[GG]] ) }}
  | aA1 = aA2             :: :: eq
  | dd |- e : A           :: :: typ
  | dd |- e => A           :: :: typ_inf
  | dd |- e <= A           :: :: typ_chk
  | dd |- pe : A :: :: ptyp {{ tex [[dd]] \vdash^\mathit{B} [[pe]] : [[A]] }}
  | CC : ( dd |- A ) ~~> ( dd' |- A' ) :: :: ctx {{ tex [[CC]] : ( [[dd]] \vdash^\mathit{B} [[A]] ) \rightsquigarrow ( [[dd']] \vdash^\mathit{B} [[A']] ) }}
  | A1 <: A2 :: :: sub
  | A1 <~ A2 :: :: csub
  | || A ||               :: :: sizeA {{ tex \llbracket [[A]] \rrbracket }}
  | || e ||e              :: :: sizeE {{ tex \llbracket [[e]] \rrbracket_\mathcal{E} }}
  | || pe ||              :: :: size {{ tex \llbracket [[pe]] \rrbracket }}
  | || pe ||e             :: :: size_e {{ tex \llbracket [[pe]] \rrbracket_\mathcal{E} }}
  | || pe ||s             :: :: size_s {{ tex \llbracket [[pe]] \rrbracket_\mathcal{S} }}
  | || pe ||g             :: :: size_g {{ tex \llbracket [[pe]] \rrbracket_\mathcal{G} }}
  | e <<= e'   :: :: eless  {{ tex [[e]] \sqsubseteq [[e']] }}
  | A <<= B   :: :: tless  {{ tex [[A]] \sqsubseteq [[B]] }}
  | pe <<= pe'   :: :: peless  {{ tex [[pe]] \sqsubseteq [[pe']] }}
  | dd1 | dd2 |- pe1 <<= pe2 :: :: bless {{ tex [[dd1]] \shortmid [[dd2]] \vdash [[pe1]] \sqsubseteq^\mathit{B} [[pe2]] }}
  | aA <~~ evar    :: :: inst
  | evar <~~ aA    :: :: inst2
  | \ pe \   ::  :: type_erasure {{ tex \lfloor [[pe]] \rfloor }}
  | pe ==> pv  ::  :: reduce 
  | pe ==> blame  ::  :: blame
  | aA1 <~ aA2 :: :: algo
  | A1 = A2    ::  :: typ_eq
  | avs1 = avs2 ::  :: avs_eq


subrules
  t <:: A
  gc <:: A
  tc <:: t
  tc <:: t
  aT <:: aA
  at <:: aT
  atc <:: at
  agc <:: aA
  asc <:: agc
  pv <:: pe

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FOB
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
FOb :: 'FOb_' ::=

defn

A ~ B ::  :: consist :: consist_ by


------- :: refl
A ~ A


------------- :: unknownR
A ~ unknown

------------- :: unknownL
unknown ~ A


A1 ~ C
B ~ D
-------------------- :: arrow
A1 -> B ~ C -> D

</ Ai ~ Ai' // i />
-------------------------------------------------- :: rcd
[ </ li : Ai // i />  ]   ~ [ </ li : Ai' // i /> ]


defn

A <: B ::  :: subtyping :: s_ by

-------------------- :: int
int <: int

-------------------- :: bool
bool <: bool

-------------------- :: float
float <: float

-------------------- :: intfloat
int <: float

C <: A1
B <: D
-------------------- :: arrow
A1 -> B <: C -> D

-------------------- :: unknown
unknown <: unknown

</ Ai <: Ai' // i />
-------------------------------------------------- :: rcd
[ </ li : Ai // i />  ]   <: [ </ li : Ai' // i /> ]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL CONSISTENCY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DConsist :: '' ::=

defn

A ~ B ::  :: dconsist :: dconsist_ by


------- :: refl
A ~ A


------------- :: unknownR
A ~ unknown

------------- :: unknownL
unknown ~ A


------------- :: unknownbR
b@(gc) ~ unknown

------------- :: unknownbL
unknown ~ b@(gc)


A1 ~ C
B ~ D
-------------------- :: arrow
A1 -> B ~ C -> D

A ~ B
------------------ :: forall
\/ a. A ~ \/ a. B

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL WELL FORMEDNESS OF TYPES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DWft :: '' ::=

defn

dd |-DK A ::  :: dkwft :: dk_wf_ by

defn

dd |-OL A ::  :: odwft :: ol_wf_ by

--------- :: int
dd |-OL int

a in dd
-------- :: tvar
dd |-OL a

dd |-OL A1
dd |-OL A2
-------------- :: arrow
dd |-OL A1 -> A2

dd, a |-OL A
-------------- :: forall
dd |-OL \/ a. A

defn

dd |-G A ::  :: dwft :: gpc_d_ by

--------- :: int
dd |-G int


--------- :: unknown
dd |-G unknown


-------------- :: static
dd |-G static

-------------- :: gradual
dd |-G gradual


a in dd
-------- :: tvar
dd |-G a

dd |-G A
dd |-G B
-------------- :: arrow
dd |-G A -> B

dd, a |-G A
-------------- :: forall
dd |-G \/ a. A

defn

dd ok :: :: ol_well_formed_tctx :: 'ol_cwf_' {{ tex [[dd]] \ [[ok]] }} by

------------------------- :: empty
empty ok

dd ok
dd |-OL A
------------------------- :: var
dd , x : A ok

dd ok
------------------------- :: tvar
dd , a ok

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL SUBTYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DSubtyping :: '' ::=

defn

|-HM A <: B ::  :: hm_subtyping :: hm_s_ by

-------------------- :: refl
|-HM t <: t

|-HM A1 [a ~> t] <: A2
----------------- :: forallL
|-HM \/ a. A1 <: A2

a notin fv(A1)
|-HM A1 <: A2
----------------- :: forallR
|-HM A1 <: \/ a . A2


defn

dd |-OL A <: B ::  :: ol_subtyping :: ol_s_ by

a in dd
-------------------- :: tvar
dd |-OL a <: a

-------------------- :: int
dd |-OL int <: int

dd |-OL A3 <: A1
dd |-OL A2 <: A4
---------------------------- :: arrow
dd |-OL A1 -> A2 <: A3 -> A4

dd |-OL t
dd |-OL A [a ~> t] <: A2
----------------- :: forallL
dd |-OL \/ a. A1 <: A2

dd, a |-OL A1 <: A2
----------------- :: forallR
dd |-OL A1 <: \/ a. A2

defn

dd |-DK A <: B ::  :: dk_subtyping :: dk_s_ by

defn

|-AP A <: B ~~> ef ::  :: ap_subtyping :: ap_s_
{{tex [[|-AP]] [[A]] [[<:]] [[B]] \transto{[[~~>]] [[ef]]} }}
by

------------------ :: int
|-AP int <: int ~~> \x:int. x

------------------ :: tvar
|-AP a <: a ~~> \x:a . x

|-AP A3 <: A1 ~~> ef1
|-AP A2 <: A4 ~~> ef2
---------------------------- :: arrow
|-AP A1 -> A2 <: A3 -> A4  ~~> \x:A1->A2. \y:A3. ef2 (x (ef1 y))

|-AP A [a ~> t] <: A2 ~~> ef
----------------- :: forallL
|-AP \/ a. A1 <: A2 ~~> \x:\/a.A1. ef (x t)

a notin fv(A1)
|-AP A1 <: A2 ~~> ef
----------------- :: forallR
|-AP A1 <: \/ a. A2 ~~> \x:A1. /\a. ef x

|-AP A1 <: C ~~> ef1
|-AP B <: D ~~> ef2
----------------------- :: pair
|-AP (A1, B) <: (C, D) ~~> ef3

defn

ss |-AP A <: B ~~> ef ::  :: ap_asubtyping :: ap_as_
{{ tex [[ss]] [[|-AP]] [[A]] [[<:]] [[B]] \transto{[[~~>]] [[ef]]} }}
by

---------------- :: empty
empty |-AP A <: A ~~> \x:A. x


ss, A3 |-AP A1 [a ~> t] <: A2 ~~> ef
------------------------ :: forall
ss, A3 |-AP \/a. A1 <: A2 ~~> \x:\/a.A1. ef (x t)


|-AP A3 <: A1 ~~> ef1
ss |-AP A2 <: A4 ~~> ef2
------------------------ :: arrow
ss, A3 |-AP A1 -> A2 <: A3 -> A4 ~~> \x:A1->A2.\y:A3. ef2 (x (ef1 y))

defn

dd |-G A <: B ::  :: dsubtyping :: gpc_s_ by


dd, a |-G A <: B
----------------- :: forallR
dd |-G A <: \/ a. B


dd |-G t
dd |-G A [a ~> t] <: B
----------------- :: forallL
dd |-G \/ a. A <: B


dd |-G r @ (t)
dd |-G A [r @ (a) ~> r @ (t) ] <: B
------------------------ :: forallLr
dd |-G r @ \/ a. A <: B

dd |-G b @ (t)
dd |-G A [b @ (a) ~> b @ (t) ] <: B
------------------------ :: forallLb
dd |-G b @ \/ a. A <: B


a in dd
-------------------- :: tvar
dd |-G a <: a


r@(a) in dd
-------------------- :: tvarr
dd |-G r@(a) <: r@(a)

b@(a) in dd
-------------------- :: tvarb
dd |-G b@(a) <: b@(a)


-------------------- :: int
dd |-G int <: int


-------------------- :: intr
dd |-G r@(int) <: r@(int)

-------------------- :: intb
dd |-G b@(int) <: b@(int)

dd |-G C <: A1
dd |-G B <: D
---------------------------- :: arrow
dd |-G A1 -> B <: C -> D


--------------------------- :: unknown
dd |-G unknown <: unknown


--------------------------- :: unknownb
dd |-G b@(unknown) <: b@(unknown)

--------------------------- :: spar
dd |-G r@(static) <: r@(static)

--------------------------- :: gparr
dd |-G r@(gradual) <: r@(gradual)

--------------------------- :: gparb
dd |-G b@(gradual) <: b@(gradual)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL CONSISTENT SUBTYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DConSub :: '' ::=

defn

dd |-G A <~ B ::  :: dconsub :: cs_ by


dd, a |-G A <~ B
----------------- :: forallR
dd |-G A <~ \/ a. B

dd |-G t
dd |-G A [a ~> t] <~ B
----------------- :: forallL
dd |-G \/ a. A <~ B

dd |-G B1 <~ A1
dd |-G A2 <~ B2
---------------------------- :: arrow
dd |-G A1 -> A2 <~ B1 -> B2

a in dd
-------------------- :: tvar
dd |-G a <~ a

-------------------- :: int
dd |-G int <~ int


--------------------------- :: unknownL
dd |-G unknown <~ A

--------------------------- :: unknownR
dd |-G A <~ unknown


--------------------------- :: unknownLL
dd |-G unknown <~ gc

--------------------------- :: unknownRR
dd |-G gc <~ unknown

--------------------------- :: spar
dd |-G static <~ static

--------------------------- :: gpar
dd |-G gradual <~ gradual


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL TYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DTyping :: '' ::=

defn

dd |- e : A ~~> pe ::  :: dtyping :: '' {{ tex [[dd]] [[|-]] [[e]] : [[A]] \transto{[[~~>]] [[pe]]} }}
by


(x : A) in dd
--------------------------- :: var
dd |- x : A ~~> x

--------------------------- :: int
dd |- n : int ~~> n

dd, a |- e : A ~~> pe
--------------------------- :: gen
dd |- e : \/ a. A ~~> /\a. pe

dd, x: A |- e : B ~~> pe
--------------------------- :: lamann
dd |- \x: A. e : A -> B ~~> \x:A. pe

dd, x: t |- e : B ~~> pe
--------------------------- :: lam
dd |- \x. e : t -> B ~~> \x:t. pe

dd |- e1 : A ~~> pe1
dd |- A |> A1 -> A2
dd |- e2 : A3 ~~> pe2
dd |- A3 <~ A1
------------------------------- :: app
dd |- e1 e2 : A2 ~~> (< A `-> A1 -> A2 > pe1) (<A3 `-> A1> pe2)


dd |- e1 : A ~~> pe1
dd, x : A |- e2 : B ~~> pe2
--------------------------------------------------- :: let
dd |- let x = e1 in e2 : B ~~>  (\x : A . pe2) pe1

defn

dd |-HM e : A  ::  :: hmtyping :: 'hm_' by

(x : A) in dd
--------------------------- :: var
dd |-HM x : A

--------------------------- :: int
dd |-HM n : int

</ ai // i /> notin fv(dd)
dd |-HM e : t
--------------------------- :: gen
dd |-HM e : \/ </ ai // i />  . t

dd, x: t1 |-HM e : t2
--------------------------- :: lam
dd |-HM \x. e : t1 -> t2

dd |-HM e1 : t1 -> t2
dd |-HM e2 : t1
------------------------------- :: app
dd |-HM e1 e2 : t2

dd |-HM e1 : A
dd, x : A |-HM e2 : t
------------------------------ :: let
dd |-HM let x = e1 in e2 : t

dd |-HM e : \/ </ ai // i /> . t
--------------------------- :: inst
dd |-HM e : t [ </ ai ~> ti // i /> ]

(x : \/ </ ai // i /> . t) in dd
--------------------------- :: var_inst
dd |-HM x : t [ </ ai ~> ti // i /> ]

dd |-HM e1 : t
</ ai // i /> = fv (t) - fv(dd)
dd, x : \/ </ ai // i/> . t |-HM e2 : t
--------------------------------------- :: let_gen
dd |-HM let x = e1 in e2 : t


defn

dd |-OL e : A  ::  :: ol_dtyping :: 'ol_' by


(x : A) in dd
--------------------------- :: var
dd |-OL x : A

--------------------------- :: int
dd |-OL n : int

dd, a |-OL e : A
--------------------------- :: gen
dd |-OL e : \/ a. A

dd, x: A1 |-OL e : A2
--------------------------- :: lamann
dd |-OL \x: A1. e : A1 -> A2

dd |-OL t
dd, x: t |-OL e : A
--------------------------- :: lam
dd |-OL \x. e : t -> A

dd |-OL e1 : A1 -> A2
dd |-OL e2 : A1
------------------------------- :: app
dd |-OL e1 e2 : A2


dd |-OL e : A1
dd |-OL A1 <: A2
--------------------------- :: sub
dd |-OL e : A2


dd |-OL e1 : A1
dd, x : A1 |-OL e2 : A2
------------------------------ :: let
dd |-OL let x = e1 in e2 : A2

defn

dd |-DK e => A  ::  :: dk_inf :: 'dk_inf_' by

(x : A) in dd
--------------------------- :: var
dd |-DK x => A

--------------------------- :: int
dd |-DK n => int

dd |-DK t1 -> t2
dd, x: t1 |-DK e => t2
--------------------------- :: lam
dd |-DK \x. e => t1 -> t2

dd |-DK e1 => A
dd |-DK A |> A1 -> A2
dd |-DK e2 <= A1
------------------------------- :: app
dd |-DK e1 e2 => A2

dd |-DK e <= A
--------------------------- :: anno
dd |-DK e : A => A

dd |-DK e1 => A
dd |-DK A . e2 =>=> A2
------------------------------- :: app2
dd |-DK e1 e2 => A2

defn

dd |-DK e <= A  ::  :: dk_chk :: 'dk_chk_' by

--------------------------- :: int
dd |-DK n <= int

dd, a |-DK e <= A
--------------------------- :: gen
dd |-DK e <= \/ a. A


dd, x: A1 |-DK e <= A2
--------------------------- :: lam
dd |-DK \x. e <= A1 -> A2


dd |-DK e => A1
dd |-DK A1 <: A2
--------------------------- :: sub
dd |-DK e <= A2


defn

dd |-DK A1 . e =>=> A  ::  :: dk_app :: 'dk_app_'
{{ tex [[dd]] [[|-DK]] [[A1]] \cdot [[e]] [[=>=>]] [[A]] }}
by

dd |-DK e <= A1
--------------------------- :: arr
dd |-DK A1 -> A2 . e =>=> A2

dd |-DK t
dd |-DK A[a ~> t] . e =>=> A1 -> A2
--------------------------- :: forall
dd |-DK \/a. A . e =>=> A1 -> A2

defn

dd ; ss |-AP e => A ~~> es  ::  :: ap_app :: 'ap_app_'
{{ tex [[dd]] ; [[ss]] [[|-AP]] [[e]] [[=>]] [[A]] \transto{[[~~>]] [[es]]} }}
by

dd |-AP e <= A1
ss |-AP A1 <: B
------------------------ :: anno
dd;ss |-AP e : A1 => B ~~> es

(x : A1) in dd
ss |-AP A1 <: A2 ~~> ef
--------------------------- :: var
dd ; ss |-AP x => A2 ~~> ef x

dd, x: A1 |-AP e => A2 ~~> es
--------------------------- :: lam
dd ; ss , A1 |-AP \x. e => A1 -> A2 ~~> \x:A1. es


|-AP A2 <: A1  ~~> ef
dd, x: A1 |-AP e => A3 ~~> es
--------------------------- :: lamann
dd ; ss, A2 |-AP \x: A1. e => A2 -> A3 ~~> \y:A2. (\x:A1. es) (ef y)


dd |-AP e2 => A1 ~~> es2
</ ai // i /> =  fv(A1) - fv(dd)
A2 = \/ </ai//i/> . A1
dd ; ss, A2 |-AP e1 => A2 -> A3 ~~> es1
------------------------------- :: app
dd ; ss |-AP e1 e2 => A3 ~~> es1 (/\ </ai//i/>. es2)


dd |-AP e => (A1, B)
ss |-AP A1 <: C
------------------------ :: fst
dd ; ss |-AP fst e => C ~~> es

dd |-AP e => (A1, B)
ss |-AP B <: C
------------------------ :: snd
dd ; ss |-AP snd e => C ~~> es

ss |-AP \/a.\/b. (a, b) -> a <: A
------------------------ :: fst_var
dd ; ss |-AP fst => A ~~> es

ss |-AP \/a.\/b. (a, b) -> b <: A
------------------------ :: snd_var
dd ; ss |-AP snd => A ~~> es

defn

dd |-gen A1 = A2 ::  :: ap_gen :: 'ap_gen' {{ tex [[dd]]_{gen} ([[A1]]) = [[A2]] }} by

defn

dd |-AP e => A ~~> ef  ::  :: ap_inf :: 'ap_inf_'
{{ tex [[dd]] [[|-AP]] [[e]] [[=>]] [[A]] \transto{[[~~>]] [[ef]]} }}

by

--------------------------- :: int
dd |-AP n => int ~~> n

dd, x: t |-AP e => A ~~> es
--------------------------- :: lam
dd |-AP \x. e => t -> A ~~> \x:t. es

dd , x: A1 |-AP e => A2 ~~> es
--------------------------- :: lamann
dd  |-AP \x: A1. e => A1 -> A2 ~~> \x:A1.es

dd |-AP e1 => A1
dd |-AP e2 => B
--------------------------- :: pair
dd |-AP (e1, e2) => (A1, B) ~~> es

defn

dd |-AP e <= A  ::  :: ap_chk :: 'ap_chk_' by

dd, x : A1 |-AP e <= B
-------------------------- :: lam
dd |-AP \x.e <= A1 -> B


dd |-AP e2 => A1
dd |-AP e1 <= A1 -> B
--------------------- :: app
dd |-AP e1 e2 <= B

defn

dd |-F es : A         ::  :: f_     :: 'f_' by

(x : A) in dd
--------------------------- :: var
dd |-F x : A

--------------------------- :: int
dd |-F n : int

dd, x: A1 |-F es : A2
--------------------------- :: lamann
dd |-F \x: A1. es : A1 -> A2

dd |-F es1 : A1 -> A2
dd |-F es2 : A1
------------------------------- :: app
dd |-F es1 es2 : A2

dd |-F es : A
a notin fv(dd)
------------------------------- :: tabs
dd |-F /\a. es : \/a. A


dd |-F es : \/a. A1
------------------------------- :: tapp
dd |-F es A2 : A1 [a~>A2]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Eta ID Equality
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
DEq :: '' ::=

defn

ef1 =nid ef2   ::  :: etaid :: eta_ by

x notin fv(ef)
------------------ :: reduce
\x. ef x =nid ef

-------------------- :: id
(\x. x) ef =nid ef

ef1 =nid ef1'
ef2 =nid ef2'
--------------------------- :: app
ef1 ef2 =nid ef1' ef2'

ef =nid ef'
------------------- :: lam
\x. ef =nid \x. ef'

-------------------- :: refl
ef =nid ef

ef =nid ef'
-------------------- :: symm
ef' =nid ef

ef1 =nid ef2
ef2 =nid ef3
-------------------- :: trans
ef1 =nid ef3

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DECL MATCHING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
DMatching :: '' ::=

defn

dd |-DK A |> B ::  :: dk_matching :: dk_m_ by


dd |-DK t
dd |-DK A [a ~> t] |> A1 -> A2
-------------------------------- :: forall
dd |-DK \/ a . A |> A1 -> A2


-------------------------- :: arr
dd |-DK A1 -> A2 |> A1 -> A2

defn

dd |- A |> B ::  :: dmatching :: m_ by


dd |- t
dd |- A [a ~> t] |> A1 -> A2
-------------------------------- :: forall
dd |- \/ a . A |> A1 -> A2


-------------------------- :: arr
dd |- A1 -> A2 |> A1 -> A2


-------------------------------------- :: unknown
dd |- unknown |> unknown -> unknown



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% WELL FORMEDNESS OF ALGO CONTEXTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Wfc :: '' ::=

defn

|- GG ::  :: wfc :: wf_ by




----------------------- :: empty
|- empty


|- GG
x notin fv(GG)
GG |- aA
----------------- :: var
|- GG , x : aA



|- GG
a notin fv(GG)
----------------- :: tvar
|- GG , a


|- GG
evar notin fv(GG)
----------------- :: evar
|- GG , evar


|- GG
evar notin fv(GG)
GG |- at
----------------- :: solved
|- GG , evar = at

|- GG
mevar notin fv(GG)
----------------- :: marker
|- GG , mevar



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO WELL FORMEDNESS OF TYPES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
AWft :: '' ::=

defn

GG |- aA ::  :: awft :: ad_ by

--------- :: int
GG |- int


--------- :: unknown
GG |- unknown


--------- :: static
GG |- static


--------- :: gradual
GG |- gradual


-------- :: tvar
GG[a] |- a


------------------ :: evar
GG[evar] |- evar


------------------ :: solved
GG[evar = at] |- evar


GG |- aA1
GG |- aA2
-------------- :: arrow
GG |- aA1 -> aA2

GG, a |- aA
-------------- :: forall
GG |- \/ a. aA



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO CONSISTENT SUBTYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
AConSub :: '' ::=

defn

GG |- aA1 <~ aA2 -| DD ::  :: aconsub :: as_
by


-------------------------- :: tvar
GG[a] |- a <~ a -| GG[a]



-------------------------- :: evar
GG[evar] |- evar <~ evar -| GG[evar]


-------------------- :: int
GG |- int <~ int -| GG


GG |- aB1 <~ aA1 -| TT
TT |- [TT] aA2 <~ [TT] aB2 -| DD
----------------------------------------- :: arrow
GG |- aA1 -> aA2 <~ aB1 -> aB2 -| DD


GG, a |- aA <~ aB -| DD, a, TT
----------------------------- :: forallR
GG |- aA <~ \/ a. aB -| DD


GG, mevar, evar |- aA [a ~> evar] <~ aB -| DD, mevar, TT
------------------------------ :: forallL
GG |- \/ a. aA <~ aB -| DD


GG, msa, sa |- aA [a ~> sa] <~ aB -| DD, msa, TT
------------------------------ :: forallLL
GG |- \/ a. aA <~ aB -| DD


--------------------------- :: spar
GG |- static <~ static -| GG

--------------------------- :: gpar
GG |- gradual <~ gradual -| GG


--------------------------- :: unknownL
GG |- unknown <~ aA -| GG

--------------------------- :: unknownR
GG |- aA <~ unknown -| GG


--------------------------- :: unknownLL
GG |- unknown <~ agc -| [agc] GG

--------------------------- :: unknownRR
GG |- agc <~ unknown -| [agc] GG


evar notin fv(aA)
GG[evar] |- evar <~~ aA -| DD
---------------------------------- :: instL
GG[evar] |-  evar <~ aA -| DD



evar notin fv(aA)
GG[evar] |- aA <~~ evar -| DD
---------------------------------- :: instR
GG[evar] |-  aA <~ evar -| DD


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INSTANTIATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
AInst :: '' ::=

defn

GG |- evar <~~ aA -| DD :: :: instl :: instl_
by



GG |- at
--------------------------------------------- :: solve
GG, evar, GG' |- evar <~~ at -| GG, evar = at, GG'


--------------------------------------------- :: solveU
GG[evar] |- evar <~~ unknown -| GG[evar]



GG |- at
--------------------------------------------- :: solveS
GG, sa, GG' |- sa <~~ at -| GG, sa = at, GG'


GG |- atc
--------------------------------------------- :: solveG
GG, ga, GG' |- ga <~~ atc -| GG, ga = atc, GG'



--------------------------------------------- :: solveUS
GG[sa] |- sa <~~ unknown -| GG[ga, sa = ga]


--------------------------------------------- :: solveUG
GG[ga] |- ga <~~ unknown -| GG[ga]


------------------------------------------------------------- :: reach
GG[evar][evarb] |- evar <~~ evarb -| GG[evar][evarb = evar]


------------------------------------------------------------- :: reachSG1
GG[sa][gb] |- sa <~~ gb -| GG[ga , sa = ga][gb = ga]


------------------------------------------------------------- :: reachSG2
GG[sb][ga] |- ga <~~ sb -| GG[gb , sb = gb][ga = gb]


------------------------------------------------------------- :: reachOther
GG[evar][evarb] |- evar <~~ evarb -| GG[evar][evarb = evar]




GG[evar2, evar1, evar = evar1 -> evar2] |- aA1 <~~ evar1 -| TT
TT |- evar2 <~~ [TT]aA2 -| DD
----------------------------------------------------------------- :: arr
GG[evar] |- evar <~~ aA1 -> aA2 -| DD




GG[evar] , b |- evar <~~ aB -| DD , b , TT
--------------------------------------- :: forallR
GG[evar] |- evar <~~ \/b . aB -| DD




defn
GG |- aA <~~ evar -| DD :: :: instr :: instr_
by

GG |- at
--------------------------------------------- :: solve
GG, evar, GG' |- at <~~ evar -| GG, evar = at, GG'


--------------------------------------------- :: solveU
GG[evar] |- unknown <~~ evar -| GG[evar]

GG |- at
--------------------------------------------- :: solveS
GG, sa, GG' |- at <~~ sa -| GG, sa = at, GG'


GG |- atc
--------------------------------------------- :: solveG
GG, ga, GG' |- atc <~~ ga -| GG, ga = atc, GG'



--------------------------------------------- :: solveUS
GG[sa] |- unknown  <~~ sa  -| GG[ga, sa = ga]


--------------------------------------------- :: solveUG
GG[ga] |- unknown  <~~ ga  -| GG[ga]



------------------------------------------------------------- :: reach
GG[evar][evarb] |- evarb <~~ evar -| GG[evar][evarb = evar]


------------------------------------------------------------- :: reachSG1
GG[sa][gb] |- gb <~~ sa -| GG[ga , sa = ga][gb = ga]


------------------------------------------------------------- :: reachSG2
GG[sb][ga] |- sb <~~ ga -| GG[gb , sb = gb][ga = gb]


------------------------------------------------------------- :: reachOther
GG[evar][evarb] |- evarb <~~ evar -| GG[evar][evarb = evar]




GG[evar2, evar1, evar = evar1 -> evar2] |- evar1 <~~ aA1 -| TT
TT |- [TT]aA2 <~~ evar2  -| DD
----------------------------------------------------------------- :: arr
GG[evar] |- aA1 -> aA2  <~~ evar -| DD


GG[evar] , mevarb, evarb |- aB[b ~> evarb] <~~ evar -| DD, mevarb, TT
-------------------------------------------------- :: forallL
GG[evar] |- \/b . aB <~~ evar -| DD


GG[evar] , msb, sb |- aB[b ~> sb] <~~ evar -| DD, msb, TT
-------------------------------------------------- :: forallLL
GG[evar] |- \/b . aB <~~ evar -| DD



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO TYPING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
ATyping :: '' ::=

defn

GG |- ae => aA -| DD ::  :: inf :: 'inf_'
by

(x : aA) in GG
--------------------------- :: var
GG |- x => aA -| GG



--------------------------- :: int
GG |- n => int -| GG


GG |- aA
GG, evarb,  x: aA |- ae <= evarb -| DD, x : aA, TT
------------------------------------------- :: lamann
GG |- \x: aA. ae => aA -> evarb -| DD


GG |- aA
GG, sb,  x: aA |- ae <= sb -| DD, x : aA, TT
------------------------------------------- :: lamann2
GG |- \x: aA. ae => aA -> sb -| DD


GG, evar, evarb, x : evar |- ae <= evarb -| DD, x : evar, TT
------------------------------------ :: lam
GG |- \x. ae => evar -> evarb  -| DD


GG, sa, sb, x : sa |- ae <= sb -| DD, x : sa, TT
------------------------------------ :: lam2
GG |- \x. ae => sa -> sb  -| DD


GG |- ae1 => aA -| TT1
TT1 |- [TT1] aA |> aA1 -> aA2 -| TT2
TT2 |- ae2 <= [TT2]aA1 -| DD
------------------------------- :: app
GG |- ae1 ae2 => aA2  -| DD



GG |- aA
GG |- ae <= aA -| DD
---------------------- :: anno
GG |- ae : aA => aA -| DD


GG |- ae1 => aA -| TT1
TT1, evar, x : aA |- ae2 <= evar -| DD, x : aA, TT2
------------------------------------------------ :: let
GG |- let x = ae1 in ae2 => evar -| DD


GG |- ae1 => aA -| TT1
TT1, sa, x : aA |- ae2 <= sa -| DD, x : aA, TT2
------------------------------------------------ :: let2
GG |- let x = ae1 in ae2 => sa -| DD

defn

GG |- ae <= aA -| DD ::  :: chk :: 'chk_'
by


GG, a |- ae <= aA -| DD , a , TT
--------------------------- :: gen
GG |- ae <= \/ a. aA -| DD



GG, x : aA |- ae <= aB -| DD, x : aA, TT
------------------------------------ :: lam
GG |- \x. ae <= aA -> aB  -| DD


GG |- ae => aA -| TT
TT |- [TT]aA <~ [TT]aB -| DD
------------------------------------ :: sub
GG |- ae <= aB -| DD


GG |- ae1 => aA -| TT
TT, x : aA |- ae2 <= aB -| DD, x : aA, TT'
------------------------------------------------ :: let
GG |- let x = ae1 in ae2 <= aB -| DD



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ALGO MATCHING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
AMatching :: '' ::=

defn

GG |- aA |> aA1 -> aA2 -| DD ::  :: amatching :: am_
by



GG , evar |- aA[a ~> evar] |> aA1 -> aA2 -| DD
-------------------------------------------- :: forall
GG |- \/a. aA |> aA1 -> aA2 -| DD


GG , sa |- aA[a ~> sa] |> aA1 -> aA2 -| DD
-------------------------------------------- :: forallL
GG |- \/a. aA |> aA1 -> aA2 -| DD


------------------------------------------ :: arr
GG |-  aA1 -> aA2 |> aA1 -> aA2 -| GG


------------------------------------------ :: unknown
GG |-  unknown |> unknown -> unknown -| GG


---------------------------------------------------------------------------------- :: var
GG[evar] |-  evar |> evar1 -> evar2 -| GG[evar1 , evar2 , evar = evar1 -> evar2]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONTEXT EXTENSION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Extension :: '' ::=


defn

GG --> DD :: :: cext :: 'ext_' by



--------------- :: id
empty --> empty



GG --> DD
[DD] aA = [DD] aA'
-------------------------------- :: var
GG , x : aA --> DD , x : aA'


GG --> DD
-------------------- :: tvar
GG , a  -->  DD , a


GG --> DD
------------------------- :: evar
GG , evar --> DD , evar


GG --> DD
[DD] at = [DD] at'
------------------------------------- :: solved
GG , evar = at --> DD , evar = at'


GG --> DD
------------------------------------- :: solve
GG , evar  --> DD , evar = at


GG --> DD
------------------------------------- :: solveS
GG , sa  --> DD , sa = at


GG --> DD
------------------------------------- :: solveG
GG , ga --> DD , ga = atc


GG --> DD
------------------------------------- :: add
GG  --> DD , evar


GG --> DD
------------------------------------- :: marker
GG, mevar  --> DD , mevar



GG --> DD
------------------------------------- :: addSolve
GG  --> DD , evar = at



GG --> DD
------------------------------------- :: addSolveS
GG  --> DD , sa = at


GG --> DD
------------------------------------- :: addSolveG
GG  --> DD , ga = atc
