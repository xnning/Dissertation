\section{Type-directed Translation, Coherence and Type-Safety}
\label{sec:AP:translation}

This section discusses the type-directed translation of System \ap into a
variant of System F that is also used in \citet{practical:inference}. The
translation is shown to be coherent and type safe. The later result implies the
type-safety of the source language. To prove coherency, we need to decide when
two translated terms are the same using \emph{$\eta$-id equality}, and show that
the translation is unique up to this definition.

\subsection{Target Language}

\begin{figure}
\centering
\begin{tabular}{lrcl} \toprule
  Expressions & $[[es]], [[ef]]$ & \syndef & $[[x]] \mid [[n]] \mid [[\x:A. es]] \mid [[/\a. es]]
                                   \mid [[es1 es2]] \mid [[es A]]$ \\
  Types & $[[A]]$ & \syndef & $[[int]] \mid [[a]] \mid [[A1 -> A2]] \mid [[\/a.A]]$\\
  Contexts & $[[dd]]$ & \syndef & $[[empty]] \mid [[dd, x:A]]$ \\
  \bottomrule
\end{tabular}
\drules[f]{$ [[dd |-F es : A ]] $}{Typing}{var,int,lamann,app,tabs,tapp}
\caption{Syntax and static semantics of System F.}
\label{fig:F}
\end{figure}

The syntax and typing rules of our target language are given in \Cref{fig:F}.

Expressions include variables $[[x]]$, integers $[[n]]$, annotated abstractions
$[[\x:A.es]]$, type-level abstractions $[[/\a.es]]$, and $[[es1 es2]]$ for term
application, and $[[es A]]$ for type application. The types and the typing
contexts are the same as our system, where typing contexts does not track type
variables. In translation, we use $[[ef]]$ to refer to the coercion function produced
by subtyping translation, and $[[es]]$ to refer to the translated term in System F.

Most typing rules are straightforward. \Rref{f-tabs} types a type abstraction
with explicit generalization, while \rref{f-tapp} types a type application with
explicit instantiation.

\subsection{Subtyping Coercions}

\renewcommand{\transto}[2][gray!40]{\colorbox{#1}{$\displaystyle#2$}}
\begin{figure}
  \renewcommand\ottaltinferrule[4]{\inferrule*[narrower=0.6,lab=#1,#2] {#3} {#4}}
  \drules[ap-s]{$ [[|-AP A1 <: A2 ~~> ef ]] $}{Subtyping Translation}{tvar,int,arrow,forallL,forallR}
  \drules[ap-as]{$ [[ss |-AP A1 <: A2 ~~> ef ]] $}{Application Subtyping}{empty,forall,arrow}
  \caption{Translation rules of System AP.}
  \label{fig:AP:sub:trans}
\end{figure}

\begin{figure}
  \renewcommand\ottaltinferrule[4]{\inferrule*[narrower=0.6,lab=#1,#2] {#3} {#4}}
  \drules[ap-inf]{$ [[dd |-AP e => A ~~> es]] $}{Typing Inference}{int,lam,lamann}
  \drules[ap-app]{$ [[dd ; ss |-AP e => A ~~> es]] $}{Typing Application Mode}{var,lam,lamann,app}
  \caption{Typing rules of System AP.}
  \label{fig:AP:trans}
\end{figure}

The type-directed translation of subtyping is shown in
\Cref{fig:AP:subtrans}. The translation follows the subtyping relations from
\Cref{fig:AP:static}, but adds a new component. The judgment $[[|-AP A1 <: A2
~~> ef]]$ is read as: if $[[|-AP A1 <: B]]$ holds, it can be translated to a
coercion function $[[ef]]$ in System F. The coercion function produced by
subtyping is used to transform values from one type to another, so we should
have $[[empty |-F ef : A1 -> B]]$.

\Rref{ap-s-int} and \rref{ap-s-tvar} produce identity functions, since the
source type and target type are the same. In \rref{ap-s-arrow}, the coercion
function $[[ef1]]$ of type $[[C -> A1]]$ is applied to $[[y]]$ to get a value of
type $[[A1]]$. Then the resulting value becomes an argument to $[[x]]$, and a
value of type $[[B]]$ is obtained. Finally we apply $[[f2]]$ to the value of
type $[[B]]$, so that a value of type $[[D]]$ is computed. In
\rref{a-ps-ForallL}, the input argument is a polymorphic type, so we feed the
type $[[t]]$ to it and apply the coercion function $[[ef]]$ from the
precondition. \Rref{ap-s-forallR} uses the coercion $[[ef]]$ and, in order to
produce a polymorphic type, we add one type abstraction to turn it into a
coercion of type $[[A1->\/a. A2]]$.

The second part of the subtyping translation deals with coercions generated by
application subtyping. The judgment $[[ss|-AP A <: B ~~> ef]]$ is read as: if
$[[ss|-AP A<:B]]$ holds, it can be translated to a coercion function $[[ef]]$ in
System F. If we compare two parts, we can see application contexts play no role
in the generation of the coercion. Notice the similarity between \rref{ap-s-tvar}
and \rref{ap-as-empty}, between \rref{ap-s-forallR} and \rref{ap-as-forall}, and
between \rref{ap-s-arrow} and \rref{ap-as-arrow}. We therefore omit more
explanations.

\subsection{Type-Directed Translation of Typing}


The type directed translation of typing is shown in the Figure
\ref{fig:AP:trans}, which extends the rules in Figure \ref{fig:AP}. The judgment
$[[dd;ss|-AP e => A ~~> es]]$ is read as: if $[[dd;ss|-AP e => A]]$ holds, the
expression can be translated to term $[[es]]$ in System F. The judgment
$[[dd|-AP e => A ~~> es]]$ is the special case when the application context is
empty.

Most translation rules are straightforward. In \rref{ap-app-var}, $[[x]]$ is
translated to $[[ef x]]$, where $[[ef]]$ is the coercion function generated from
subtyping. \Rref {ap-app-lamann} applies the coercion function $[[ef]]$ to
$[[y]]$, then feeds $[[y]]$ to the function generated from the abstraction. When
generalizing over a type, \rref{ap-app-app} generate type-level abstractions.

\subsection{Type Safety}

We prove that our system is type safe by proving that the translation produces
well-typed terms.

\begin{lemma}[Soundness of Typing Translation]
  If $[[dd;ss|-AP e => A ~~> es]]$,
  then $[[dd|-F es : A]]$.
\end{lemma}

The lemma relies on the translation of subtyping to produce type-correct
coercions.

\begin{lemma}[Soundness of Subtyping Translation]\leavevmode
  \begin{enumerate}
  \item
    If $[[|-AP A <: B ~~> ef]]$,
    then $[[empty|-F ef : A -> B]]$.
  \item
    If $[[ss|-AP A <: B ~~> ef]]$,
    then $[[empty|-F ef : A -> B]]$.
  \end{enumerate}
\end{lemma}

\subsection{Coherence}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../../Thesis.bib"
%%% End: