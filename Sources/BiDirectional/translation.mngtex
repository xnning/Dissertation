\section{Type-directed Translation}
\label{sec:AP:translation}

This section discusses the type-directed translation of System \ap into a
variant of System F that is also used in \citet{practical:inference}. The
translation is shown to be coherent and type safe. The later result implies the
type-safety of the source language. To prove coherency, we need to decide when
two translated terms are the same using \emph{$\eta$-id equality}, and show that
the translation is unique up to this definition.

\subsection{Target Language}

\begin{figure}
\centering
\begin{tabular}{lrcl} \toprule
  Expressions & $[[es]], [[ef]]$ & \syndef & $[[x]] \mid [[n]] \mid [[\x:A. es]] \mid [[/\a. es]]
                                   \mid [[es1 es2]] \mid [[es A]]$ \\
  Types & $[[A]]$ & \syndef & $[[int]] \mid [[a]] \mid [[A1 -> A2]] \mid [[\/a.A]]$\\
  Contexts & $[[dd]]$ & \syndef & $[[empty]] \mid [[dd, x:A]]$ \\
  \bottomrule
\end{tabular}
\drules[f]{$ [[dd |-F es : A ]] $}{Typing}{var,int,lamann,app,tabs,tapp}
\caption{Syntax and typing rules of System F.}
\label{fig:F}
\end{figure}

The syntax and typing rules of our target language are given in \Cref{fig:F}.

Expressions include variables $[[x]]$, integers $[[n]]$, annotated abstractions
$[[\x:A.es]]$, type-level abstractions $[[/\a.es]]$, and $[[es1 es2]]$ for term
application, and $[[es A]]$ for type application. The types and the typing
contexts are the same as our system, where typing contexts does not track type
variables. In translation, we use $[[ef]]$ to refer to the coercion function produced
by subtyping translation, and $[[es]]$ to refer to the translated term in System F.

Most typing rules are straightforward. \Rref{f-tabs} types a type abstraction
with explicit generalization, while \rref{f-tapp} types a type application with
explicit instantiation.

\subsection{Subtyping Coercions}

\renewcommand{\transto}[2][gray!40]{\colorbox{#1}{$\displaystyle#2$}}
\begin{figure}
  \renewcommand\ottaltinferrule[4]{\inferrule*[narrower=0.6,lab=#1,#2] {#3} {#4}}
  \drules[ap-s]{$ [[|-AP A1 <: A2 ~~> ef ]] $}{Subtyping Translation}{tvar,int,arrow,forallL,forallR}
  \drules[ap-as]{$ [[ss |-AP A1 <: A2 ~~> ef ]] $}{Application Subtyping}{empty,forall,arrow}
  \caption{Subtyping translation rules of System AP.}
  \label{fig:AP:sub:trans}
\end{figure}

\begin{figure}
  \renewcommand\ottaltinferrule[4]{\inferrule*[narrower=0.6,lab=#1,#2] {#3} {#4}}
  \drules[ap-inf]{$ [[dd |-AP e => A ~~> es]] $}{Typing Inference}{int,lam,lamann}
  \drules[ap-app]{$ [[dd ; ss |-AP e => A ~~> es]] $}{Typing Application Mode}{var,lam,lamann,app}
  \caption{Typing translation rules of System AP.}
  \label{fig:AP:trans}
\end{figure}

The type-directed translation of subtyping is shown in
\Cref{fig:AP:subtrans}. The translation follows the subtyping relations from
\Cref{fig:AP:static}, but adds a new component. The judgment $[[|-AP A1 <: A2
~~> ef]]$ is read as: if $[[|-AP A1 <: B]]$ holds, it can be translated to a
coercion function $[[ef]]$ in System F. The coercion function produced by
subtyping is used to transform values from one type to another, so we should
have $[[empty |-F ef : A1 -> B]]$.

\Rref{ap-s-int} and \rref{ap-s-tvar} produce identity functions, since the
source type and target type are the same. In \rref{ap-s-arrow}, the coercion
function $[[ef1]]$ of type $[[C -> A1]]$ is applied to $[[y]]$ to get a value of
type $[[A1]]$. Then the resulting value becomes an argument to $[[x]]$, and a
value of type $[[B]]$ is obtained. Finally we apply $[[f2]]$ to the value of
type $[[B]]$, so that a value of type $[[D]]$ is computed. In
\rref{a-ps-ForallL}, the input argument is a polymorphic type, so we feed the
type $[[t]]$ to it and apply the coercion function $[[ef]]$ from the
precondition. \Rref{ap-s-forallR} uses the coercion $[[ef]]$ and, in order to
produce a polymorphic type, we add one type abstraction to turn it into a
coercion of type $[[A1->\/a. A2]]$.

The second part of the subtyping translation deals with coercions generated by
application subtyping. The judgment $[[ss|-AP A <: B ~~> ef]]$ is read as: if
$[[ss|-AP A<:B]]$ holds, it can be translated to a coercion function $[[ef]]$ in
System F. If we compare two parts, we can see application contexts play no role
in the generation of the coercion. Notice the similarity between \rref{ap-s-tvar}
and \rref{ap-as-empty}, between \rref{ap-s-forallR} and \rref{ap-as-forall}, and
between \rref{ap-s-arrow} and \rref{ap-as-arrow}. We therefore omit more
explanations.

\subsection{Type-Directed Translation of Typing}


The type directed translation of typing is shown in the Figure
\ref{fig:AP:trans}, which extends the rules in Figure \ref{fig:AP}. The judgment
$[[dd;ss|-AP e => A ~~> es]]$ is read as: if $[[dd;ss|-AP e => A]]$ holds, the
expression can be translated to term $[[es]]$ in System F. The judgment
$[[dd|-AP e => A ~~> es]]$ is the special case when the application context is
empty.

Most translation rules are straightforward. In \rref{ap-app-var}, $[[x]]$ is
translated to $[[ef x]]$, where $[[ef]]$ is the coercion function generated from
subtyping. \Rref {ap-app-lamann} applies the coercion function $[[ef]]$ to
$[[y]]$, then feeds $[[y]]$ to the function generated from the abstraction. When
generalizing over a type, \rref{ap-app-app} generate type-level abstractions.

\subsection{Type Safety}

We prove that our system is type safe by proving that the translation produces
well-typed terms.

\begin{lemma}[Soundness of Typing Translation]
  If $[[dd;ss|-AP e => A ~~> es]]$,
  then $[[dd|-F es : A]]$.
\end{lemma}

The lemma relies on the translation of subtyping to produce type-correct
coercions.

\begin{lemma}[Soundness of Subtyping Translation]\leavevmode
  \begin{enumerate}
  \item
    If $[[|-AP A <: B ~~> ef]]$,
    then $[[empty|-F ef : A -> B]]$.
  \item
    If $[[ss|-AP A <: B ~~> ef]]$,
    then $[[empty|-F ef : A -> B]]$.
  \end{enumerate}
\end{lemma}

\subsection{Coherence}

One problem with the translation is that there are multiple targets
corresponding to one expression. This is because in original system there are
multiple choices when instantiating a polymorphic type, or guessing the
annotation for unannotated lambda abstraction (\rref{ap-inf-lam}). For each
choice, the corresponding target will be different. For example, expression
$[[\x.x]]$ can be type checked with $[[int->int]]$, or $[[a->a]]$, and the
corresponding targets are $[[\x:int.x]]$, and $[[\x:a.x]]$.


Therefore, in order to prove the translation is coherent, we turn to prove that
all the translations have the same operational semantics. There are two steps
towards the goal: type erasure, and considering $\eta$ expansion and identity
functions.

\begin{figure}
  \centering
  \begin{tabular}{llp{3cm}lll}\toprule
    $[[|x|]]$ & = & $[[|x|]]$ & $[[|/\a. es|]]$ & = & $[[|es|]]$\\
    $[[|n|]]$ & = & $[[|n|]]$ & $[[|es1 es2|]]$ & = & $[[|es1| |es2|]]$\\
    $[[|\x:A. es|]]$ & = & $[[\x.|es|]]$& $[[|es A|]]$ & = & $[[|es|]]$\\
    \bottomrule
  \end{tabular}
  \drules[eta]{$ [[ef1 =nid ef2]] $}{Eta-id Equality}{reduce,id,app,lam,refl,symm,trans}
  \caption{Type erasure and eta-id equality of System F.}
  \label{fig:erasure}
\end{figure}

\paragraph{Type Erasure.}

Since type information is useless after type-checking, we erase the type
information of the targets for comparison. The erasure process is given at the
top of \Cref{fig:erasure}.

The erasure process is standard, where we erase the type annotation in
abstractions, and remove type abstractions and type applications. The calculus
after erasure is the untyped lambda calculus.

\paragraph{Eta-id Equality.}

However, even if we have type erasure, multiple targets for one expression can
still be syntactically different. The problem is that we can insert more
coercion functions in one translation than another, since an expression can have
a more polymorphic type in one derivation than another one. So we need a more
refined definition of equality instead of syntactic equality.

We use a similar definition of eta-id equality as in \citet{chen:coercive},
given in \Cref{fig:erasure}. In $[[=nid]]$ equality, two expressions are
regarded as equivalent if they can turn into the same expression through
$\eta$-reduction or removal of redundant identity functions. The $[[=nid]]$
relation is reflexive, symmetrical, and transitive. As a small example, we can
show that $[[\x. (\y.y) ef x =nid ef]]$.
%
\[
  \inferrule*[right=\rref*{eta-reduce}]{
    \inferrule*[right=\rref*{eta-id}]{
      \inferrule*[right=\rref*{eta-refl}]
      {\quad}
      {[[ef =nid ef]]}
    }{
    [[(\y.y) ef =nid ef]]
    }
  }{
    [[\x. (\y.y) ef x =nid ef]]
  }
\]

Now we first prove that the erasure of the translation result of subtyping is
always $[[=nid]]$ to an identity function.

\begin{lemma}[Subtyping Coercions eta-id equal to $[[id]]$]\leavevmode
  \begin{itemize}
  \item if $[[|-AP A1 <: B ~~> ef]]$, then $[[ |ef| =nid \x.x ]]$.
    \item if $[[ss |-AP A1 <: B ~~> ef]]$, then $[[ |ef| =nid \x.x ]]$.
  \end{itemize}
\end{lemma}

We then prove that our translation actually generates a \textit{unique} target:

\begin{lemma}[Coherence]
  If $[[dd1;ss1|-AP e => A ~~> es1]]$,
  and $[[dd2;ss2|-AP e => B ~~> es2]]$,
  then $[[|es1| =nid |es2|]]$.
\end{lemma}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../../Thesis.bib"
%%% End: