\section{Declarative System}

This section first presents the declarative, \emph{syntax-directed}
specification of \ap. The interesting aspects about the new type system
are: 1) the typing rules, which employ a combination of inference and \mode
modes; 2) the novel subtyping relation under an application context.

% Later, we prove our type system is type-safe by a type
% directed translation to System F\citep{systemF}.
% in
% Section~\ref{subsec:translation}. Finally an algorithmic type system is discussed
% in Section~\ref{subsec:algorithmic}.

\subsection{Syntax}

\begin{figure}
  \centering
  \begin{tabular}{lrcl} \toprule
    Expressions & $[[e]]$  & $\Coloneqq$ & $[[x]]  \mid [[n]]  \mid [[\x : A . e]] \mid [[ \x . e ]] \mid [[e1 e2]] $ \\
    Types       & $[[A]]$  & $\Coloneqq$ & $[[int]] \mid [[a]] \mid [[A1 -> A2]] \mid [[\/ a. A]] $ \\
    Monotypes   & $[[t]]$  & $\Coloneqq$ & $[[int]] \mid [[a]] \mid [[t1 -> t2]] $ \\
    Contexts    & $[[dd]]$ & $\Coloneqq$ & $[[empty]]  \mid [[dd , x : A]]  $ \\
    Application Contexts & $[[ss]]$ & $\Coloneqq$ & $[[empty]]  \mid [[ss, A]]  $ \\
    \bottomrule
    \end{tabular}
  \caption{Syntax of System \ap.}
  \label{fig:AP}
\end{figure}

The syntax of the language is given in \Cref{fig:AP}.

\paragraph{Expressions.}

The definition of expressions $[[e]]$ include variables ($[[x]]$), integers
($[[n]]$), annotated lambda abstractions ($[[\x:A . e]]$), lambda abstractions
($[[\x.e]]$), and applications ($[[e1 e2]]$). Notably, the syntax does not
include a $[[let]]$ expression ($[[let x = e1 in e2]]$). Let expressions can be
regarded as the standard syntax sugar $[[(\x. e2) e1]]$, as illustrated in more
detail later.

\paragraph{Types.} 

Types include the integer type $[[int]]$, type variables ($[[a]]$), functions
($[[A1 -> A2]]$) and polymorphic types ($[[\/a. A]]$). Monotypes are types
without universal quantifiers.


\paragraph{Contexts.}

Typing contexts $[[dd]]$ are standard: they map a term variable $[[x]]$ to its
type $[[A]]$. In this system, the context is modeled in a HM-style context
(\Cref{sec:HM}), which does not track type variables. Again, we implicitly
assume that all the variables in $[[dd]]$ are distinct.

The main novelty lies in the \emph{application contexts} $[[ss]]$, which are the
main data structure needed to allow types to flow from arguments to functions.
Application contexts are modeled as a stack. The stack collects the types of
arguments in applications. The context is a stack because if a type is pushed
last then it will be popped first. For example, inferring expression $[[e]]$
under application context ($[[a, int]]$), means $[[e]]$ is now being applied to
two arguments $[[e1]], [[e2]]$, with $[[e1:int]]$, $[[e2 :a]]$, so $[[e]]$
should be of type $[[int -> a -> A]]$ for some $[[A]]$.

\subsection{Type System}

\begin{figure}
  \renewcommand\ottaltinferrule[4]{
    \inferrule*[narrower=0.6,lab=#1,#2]
    {#3}
    {#4}
  }
  \drules[ap-inf]{$ [[dd |-AP e => A ]] $}{Typing Inference}{int,lam,lamann}
  \drules[ap-app]{$ [[dd ; ss |-AP e => A ]] $}{Typing Application Mode}{var,lam,lamann,app}
  \drules[ap-as]{$ [[ss |-AP A1 <: A2 ]] $}{Application Subtyping}{empty,forall,arrow}

  \caption{Typing rules of System AP.}
  \label{fig:AP:static}
\end{figure}

The top part of Figure \ref{fig:AP:static} gives the typing rules for our
language. The judgment $[[dd ; ss |-AP e => A]]$ is read as: under typing
context $[[dd]]$, and application context $[[ss]]$, $[[e]]$ has type $[[A]]$.
The standard inference mode $[[dd |-AP e => A]]$ can be regarded as a special
case when the application context is empty. Note that the variable names are
assumed to be fresh enough when new variables are added into the typing context,
or when generating new type variables.

We discuss the rules when the application context is empty first. Those rules
are unsurprising. \Rref{ap-inf-int} shows that integer literals are only
inferred to have type $[[int]]$ under an empty application context. This is
obvious since an integer cannot accept any arguments. \Rref{ap-inf-lam} deals
with lambda abstractions when the application context is empty. In this
situation, a monotype $[[t]]$ is \emph{guessed} for the argument, just like
previous calculi. \Rref{ap-inf-lamann} also works as expected: a new variable
$[[x]]$ is put with its type $[[A]]$ into the typing context, and inference
continues on the abstraction body.

Now we turn to the cases when the application context is not empty.
\Rref{ap-app-var} says that if $[[x: A1]]$ is in the typing context, and
$[[A1]]$ is a subtype of $[[A2]]$ under application context $[[ss]]$, then
$[[x]]$ has type $[[A2]]$. It depends on the subtyping rules that are explained
in Section TODO.

\Rref{ap-app-lam} shows the strength of application contexts. It states that, without
annotations, if the application context is non-empty, a type can be popped from
the application context to serve as the type for $[[x]]$. Inference of the body then
continues with the rest of the application context. This is possible, because
the expression $[[\x. e]]$ is being applied to an argument of type $[[A1]]$, which
is the type at the top of the application context stack.

For lambda abstraction with annotations $[[\x:A1. e]]$, if the and the
application context has $[[A2]]$, then \rref{ap-app-lamann} first checks that
$[[A2]]$ is a subtype of $[[A1]]$ before putting $[[x:A1]]$ in the typing
context. However, note that it is always possible to remove annotations in an
abstraction if it has been applied to some arguments.

\Rref{ap-app-app} pushes types into the application context. The application
rule first infers the type of the argument $[[e2]]$ with type $[[A1]]$. Then the
type $[[A1]]$ is generalized in the same way as the HM type system. The
resulting generalized type is $[[A2]]$. Thus the type of $[[e1]]$ is now
inferred under an application context extended with type $[[A2]]$. The
generalization step is important to infer higher ranked types: since $[[A2]]$ is
a possibly polymorphic type, which is the argument type of $[[e1]]$, then
$[[e1]]$ is of possibly a higher rank type.

\paragraph{Let Expressions.}

The language does not have built-in let expressions, but instead supports
$[[let]]$ as syntactic sugar. The typing rule for let expressions in the
HM system is (without the gray-shaded part):

\[
  \inferrule{[[dd |- e1 => A1]]\\
    [[dd |-gen  A1 = A2]] \\
    [[dd, x:A2 |- e2 => A3]]}
  {[[dd |- let x = e1 in e2 => A3]]}
\]

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../../Thesis.bib"
%%% End: