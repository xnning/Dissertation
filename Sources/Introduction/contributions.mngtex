\section{Contributions}

In this dissertation, we study the type inference problem of predicative
implicit higher-rank polymorphism, and integrate techniques we have developed
into other advanced type system features including \textit{gradual typing}
\citep{siek2007gradual} and \textit{kind inference}. Specifically, the
dissertation consists of three main technical parts: bidirectional type checking
with the new \textit{\mode} mode, integration of higher-rank polymorphism and
gradual typing, and a type unification technique called \textit{type promotion}
that helps build simpler \textit{type unification} process.


\paragraph{\Cref{part:typeinference}: Bidirectional type checking with application mode.}

Bidirectional type checking has been known in the folklore of type systems for a
long time. It was popularized by Pierce and Turner's work on \emph{local type
  inference}~\citep{pierce:local}. Local type inference was introduced as an
alternative to Hindley-Milner type systems~\citep{hindley,Damas:Milner}, which
could easily deal with polymorphic languages with subtyping. Bidirectional type
checking is one component of local type inference that, aided by some type
annotations, enables type inference in an expressive language with polymorphism
and subtyping. Since Pierce and Turner's work, various other authors have proved
the effectiveness of bidirectional type checking in several other settings,
including many different systems with
subtyping~\citep{DK,dunfield:tridirectional,davies2000intersection}, systems
with dependent types~\citep{xi:dependent, coquand:algorithm, abel2008verifying,
  loh:tutorial, asperti2012bi}, and various other
works~\citep{abel2004termination, dunfield2009greedy, pientka2008type,
  chlipala2005strict, lovas2010refinement}. Furthermore, bidirectional type
checking has also been combined with HM-style techniques for providing type
inference in the presence of higher-rank types~\citep{practical:inference,
  DK}.

The key idea in bidirectional type checking is simple. In its basic form typing
is split into \emph{inference} and \emph{checking} modes. The most salient
feature of a bidirectional type checker is when information deduced from
inference mode is used to guide checking of an expression in checking mode. One
of such interactions between modes happens in the typing rule for function
applications. In particular, when type checking $[[e1 e2]]$, we first synthesize
the type of $[[e1]]$, and then check $[[e2]]$ with the expected argument type we
get from the type of $[[e1]]$.

We study a variant of bidirectional type checking that employs a so-called
\emph{\mode} mode. With the \mode mode, when type checking $[[e1 e2]]$, the type
information of $[[e2]]$ flows into $[[e1]]$. With the application mode it is
possible to infer the type for expressions such as \lstinline{(\x. x) 1} without
additional annotations.

Bidirectional type checking with an \mode mode may still require type
annotations and it gives different trade-offs with respect to the checked mode
in terms of type annotations. However the different trade-offs open paths to
different designs of type checking/inference algorithms. To illustrate the
utility of the \mode mode, we present a higher-rank implicit polymorphic type
system, which infers higher-rank types, generalizes the HM type system, and has
polymorphic $[[let]]$ as syntactic sugar. As far as we are aware, no previous
work enables an HM-style let construct to be expressed as syntactic sugar.

We believe that, similarly to standard bidirectional type checking,
bidirectional type checking with an \mode mode can be applied to a wide range
of type systems. Our work show a particular and non-trivial application.
Other potential areas of applications are other type systems with subtyping,
static overloading, implicit parameters or dependent types.

\paragraph{\Cref{part:gradual}: Higher-rank polymorphism and gradual typing.}

Gradual typing~\citep{siek2006gradual} is an increasingly popular topic in both
programming language practice and theory. On the practical side there is a
growing number of programming languages adopting gradual typing. Those languages
include Clojure~\citep{Bonnaire_Sergeant_2016}, Python~\citep{Vitousek_2014, lehtosalo2016mypy},
TypeScript~\citep{typescript}, Hack~\citep{verlaguet2013facebook}, and the
addition of Dynamic to C\#~\citep{Bierman_2010}, to name a few. On the
theoretical side, recent years have seen a large body of research that defines
the foundations of gradual typing~\citep{garcia:abstracting,
  cimini2016gradualizer, CiminiPOPL}, explores their use for both functional and
object-oriented programming~\citep{siek2006gradual, siek2007gradual}, as well as
its applications to many other areas~\citep{Ba_ados_Schwerter_2014,
  castagna2017gradual, Jafery:2017:SUR:3093333.3009865}.

A key concept in gradual type systems is
\emph{consistency}~\citep{siek2006gradual}. Consistency weakens type equality to allow
for the presence of \emph{unknown} types $[[ unknown ]]$. In some gradual type systems
with subtyping, consistency is combined with subtyping to give rise to
the notion of \emph{consistent subtyping}~\citep{siek2007gradual}. Consistent
subtyping is employed by gradual type systems to validate type
conversions arising from conventional subtyping. One nice feature of consistent
subtyping is that it is derivable from the more primitive
notions of \emph{consistency} % (arising from gradual typing)
and \emph{subtyping}. As \citet{siek2007gradual}
put it, this shows that
``gradual typing and subtyping are orthogonal and can be combined in a principled fashion''.
Thus consistent subtyping is often used as a guideline for
designing gradual type systems with subtyping. 

Unfortunately, as noted by \citet{garcia:abstracting}, notions of consistency
and/or consistent subtyping ``become more difficult to adapt as type systems get
more complex''. In particular, for the case of type systems with subtyping,
certain kinds of subtyping do not fit well with the original definition of
consistent subtyping by \citet{siek2007gradual}. One important case where such a
mismatch happens is in type systems supporting implicit (higher-rank)
polymorphism. It is well-known that polymorphic types \`a la System F
induce a subtyping relation that relates polymorphic types to their
instantiations~\citep{odersky:putting, mitchell1990polymorphic}. However
\citeauthor{siek2007gradual}'s definition is not adequate for this kind of
subtyping. Moreover the current framework for \emph{Abstracting Gradual Typing}
(AGT)~\citep{garcia:abstracting} does not account for polymorphism either,
but the authors acknowledge that it is an interesting avenue for future work.

This part first studies the gradually typed subtyping and
consistent subtyping relations for implicit higher-rank polymorphism. To
accomplish this, we first show how to reconcile consistent subtyping with
polymorphism by generalizing the original consistent subtyping definition by
\citeauthor{siek2007gradual}. Our new definition of consistent subtyping can
deal with polymorphism, and preserves the orthogonality between consistency and
subtyping. To slightly rephrase \citeauthor{siek2007gradual}, the motto of this
work is that: \emph{Gradual typing and polymorphism are orthogonal and
  can be combined in a principled fashion.}\footnote{Note here that we borrow
  \citeauthor{siek2007gradual}'s motto mostly to talk about the static
  semantics. As \citet{amal:blame} show there are several non-trivial
  interactions between polymorphism and casts at the level of the dynamic
  semantics.}
As a step towards an algorithmic version of consistent subtyping, we present a
syntax-directed version of consistent subtyping that is sound and complete with
respect to our formal definition of consistent subtyping. The syntax-directed
version of consistent subtyping is remarkably simple and well-behaved, and does
not require the \emph{restriction} operator of \citet{siek2007gradual}.

We then present the design of \gpc, which stands for
\textbf{G}radually \textbf{P}olymorphic \textbf{C}alculus: a (source-level)
gradually typed calculus for (predicative) implicit higher-rank polymorphism
that uses our new notion of consistent subtyping. As far as we are aware, there
is no work on bridging the gap between implicit higher-rank polymorphism and
gradual typing, which is interesting for two reasons. On the one hand, modern
functional languages such as Haskell employ sophisticated type-inference
algorithms that, aided by type annotations, can deal with implicit higher-rank
polymorphism. So a natural question is how gradual typing can be integrated in
such languages. On the other hand, there are several existing works on
integrating \emph{explicit} polymorphism into gradual typing \citep{amal:blame,
  yuu2017poly}. Yet no work investigates how to move its expressive power into a
source language with implicit polymorphism. Therefore as a step towards
gradualizing such type systems, we develop both declarative and
algorithmic versions for a gradual type system with implicit higher-rank
polymorphism. The new calculus brings the expressive power of full implicit
higher-rank polymorphism into a gradually typed source language.

% We prove that
% our calculus satisfies all of the \emph{static} aspects of the refined criteria
% for gradual typing~\cite{siek2015refined}. As a step towards the \emph{dynamic
%   gradual guarantee} property~\citep{siek2015refined}, we propose an extension
% of our calculus. This extension employs \emph{static type parameters}, which are
% placeholders for monotypes, and \emph{gradual type parameters}, which are
% placeholders for monotypes that are consistent with the unknown type. The
% concept of static type parameters and gradual type parameters in the context of
% gradual typing was first introduced by \citet{garcia:principal}, and later
% played a central role in the work of \citet{yuu2017poly}\footnote{The static and
%   gradual type variables in their work.}. With this extension it becomes
% possible to talk about \emph{representative translations}: those translations
% that generalize a number of other translations using specific monotypes. Our
% work recasts the dynamic gradual guarantee in terms of representative
% translations. Assuming a coherence conjecture regarding representative
% translations, the dynamic gradual guarantee of our extended source language now
% can be reduced to that of \pbc. Nonetheless, we believe our discussion of
% representative translations is helpful in shedding some light on this issue.

\paragraph{\Cref{part:dependentTypes}: Type Promotion and Kind Inference.}






\paragraph{Contributions.}

In summary the contributions of this dissertation are:

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../../Thesis.bib"
%%% End: