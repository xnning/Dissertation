\section{Contributions}

The goal of this dissertation is to explore the design space of type inference
for implicit predicative higher-rank polymorphism, as well as to study the
integration of techniques we have developed into other advanced type system
features including \textit{gradual typing} \citep{siek2007gradual} and
\textit{kind inference}.

In particular, I offer the following specific contributions:

% -----------------------------------------------------------

\begin{description}
\item[\Cref{part:typeinference}]
  \begin{itemize}
  \item \Cref{chap:BiDirectional} presents an implicit higher-rank polymorphic
    type system \ap, which infers higher-rank types, generalizes the HM type
    system, and has polymorphic $[[let]]$ as syntactic sugar. As far as we are
    aware, no previous work enables an HM-style let construct to be expressed as
    syntactic sugar.

    The system is defined based on a variant of \textit{bidirectional type
      (checking)} \citep{pierce:local} with a new \textit{application} mode. The
    new variant preserves the advantage of bidirectional type checking, namely
    many redundant type annotations are removed, while certain programs can type
    check with even fewer annotations. We believe that, similarly to standard
    bidirectional type checking, bidirectional type checking with an \mode mode
    can be applied to a wide range of type systems.
  \end{itemize}

% -----------------------------------------------------------

\item[\Cref{part:gradual}]
  \begin{itemize}
  \item \cref{chap:Gradual} integrates implicit higher-rank polymorphism with
    \textit{gradual types}\citep{siek2006gradual}, which is, as far as we are
    aware, the first work on bridging the gap between implicit higher-rank
    polymorphism and gradual typing.

    We start by studying the gradually typed subtyping and \textit{type
      consistent} \citep{siek2006gradual}, the central concept for gradual
    typing, for implicit higher-rank polymorphism. To accomplish this, we first
    define a framework for \textit{consistent
      subtyping}~\citep{siek2007gradual} with

    \begin{itemize}
    \item a new definition of consistent subtyping that subsumes and generalizes
      that of \citeauthor{siek2007gradual}, and can deal with polymorphism and
      top types. Our new definition of consistent subtyping preserves the
      orthogonality between consistency and subtyping. To slightly rephrase
      \cite{siek2007gradual}, the motto of this framework is that: \emph{Gradual
        typing and polymorphism are orthogonal and can be combined in a
        principled fashion.}\footnote{Note here that we borrow
        \citeauthor{siek2007gradual}'s motto mostly to talk about the static
        semantics. As \citet{amal:blame} show there are several non-trivial
        interactions between polymorphism and casts at the level of the dynamic
        semantics.}
    \item a syntax-directed version of consistent subtyping that is sound and
      complete with respect to our definition of consistent subtyping.
      % , but still guesses instantiations.
      The syntax-directed
      version of consistent subtyping is remarkably simple and well-behaved, and does
      not require the \emph{restriction} operator of \citet{siek2007gradual}.
    \end{itemize}


    Based on consistent subtyping, we then present the design of \gpc, which
    stands for \textbf{G}radually \textbf{P}olymorphic \textbf{C}alculus: a
    (source-level) gradually typed calculus for predicative implicit higher-rank
    polymorphism that uses our new notion of consistent subtyping.
    We prove that our calculus
    satisfies the static aspects of the refined criteria for gradual typing
    \citep{siek:criteria}, and is type-safe by a type-directed translation to
    \pbc \citep{amal:blame}. We then give a sound and complete bidirectional
    algorithm for implementing the declarative system based on the design
    principle of \cite{garcia:principal}.

  \item \Cref{chap:Dynamic} proposes an extension of \gpc with type
    parameters~\citep{garcia:principal} as a step towards restoring the
    \emph{dynamic gradual guarantee}~\citep{siek:criteria}. The extension
    significantly changes the algorithmic system. The new algorithm features a
    novel use of existential variables with a different solution space, which is
    a natural extension of the approach by \citet{DK}.
  \end{itemize}

% -----------------------------------------------------------

\item[\Cref{part:promotion}]
  \begin{itemize}
  \item \Cref{chap:Promotion} proposes an arguably simpler algorithmic subtyping of the
    type inference algorithm for higher-rank implicit polymorphism, based on a
    new strategy called \textit{promotion} in the \textit{type inference in
      context} \citep{gundry2010type, DK} framework. Promotion helps resolve the
    dependency between variables during solving, and can be naturally
    generalized to more complicated types.

    In this part, we first apply promotion to the unification algorithm for
    simply typed lambda calculus, and then its polymorphic extension to the
    subtyping algorithm for implicit predicative higher-rank polymorphism.

  \item \Cref{chap:kindinference} applies the design of promotion in the context
    of kind inference for datatypes, and presents two kind inference systems for
    Haskell. The first system, we believe, is the first formalization of this
    aspect of Haskell98, and the second one models the challenging features for
    kind inference in modern Haskell. Specifically,
      \begin{itemize}
    \item We formalize Haskell98's datatype declarations, providing both a
      declarative specification and syntax-driven algorithm for kind inference.
      We prove that the algorithm is sound and observe how Haskell98's technique
      of \textit{defaulting} leads to incompleteness.
    \item We then present a type and kind language that is unified and dependently
      typed, modeling the challenging features for kind inference in modern
      Haskell. We include both a declarative specification and a syntax-driven
      algorithm. The algorithm is proved sound, and we observe where and why
      completeness fails. In the design of our algorithm, we must choose between
      completeness and termination; we favor termination but conjecture that an
      alternative design would regain completeness. Unlike other dependently typed
      languages, we retain the ability to infer top-level kinds instead of relying
      on compulsory annotations.
    \end{itemize}
  \end{itemize}

\end{description}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../../Thesis.bib"
%%% End: