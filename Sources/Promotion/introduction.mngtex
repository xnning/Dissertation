\section{Introduction and Motivation}


\subsection{Background:Type Inference in Context}
\label{sec:pr:background}

\cite{gundry2010type} model unification and type inference from a general
perspective of information increase. Specifically, they studied the unification
and type inference problem for a ML-style
polymorphic system, based on the requirement that types may depend only on
earlier bindings in the type context.
% DK \citep{DK} provides a
% meta-theoretical foundation for this strategy in a bi-directional algorithm for
% higher-rank polymorphism, which is later adopted in \gpc (\Cref{chap:Gradual}).
Besides contexts being ordered, a key insight of the approach lies in how to
solve existential variables with other types. In particular, it requires to
resolve the dependency between existential variables. Consider unifying
$[[evar]]$ with $[[evarb -> int]]$ under the context $[[evar, evarb]]$. Here we
cannot simply set $[[evar]]$ to $[[evarb -> int]]$, as $[[evarb]]$ is out of the
scope of $[[evar]]$. The way \cite{gundry2010type} solve this problem is to
examine variables in the context from the tail to the head, \textit{moving
  segments of the context to the left if necessary}. The process finishes when the
existential variable being unified is found. In this case, \cite{gundry2010type}
would return a solution context $[[evarb, evar = evarb -> int]]$, where
$[[evarb]]$ is moved to the front of $[[evar]]$. However, while moving type
variables around is a feasible way to resolve the dependency between existential
variables, the unpredictable context movements make the information increase
hard to formalize and reason about. In their system, the information increase of
contexts is defined in a semantic way: a context $[[GG1]]$ is more informative
than another context $[[GG2]]$, if there exists a substitution such that every
item in $[[GG2]]$ is, after context substitution, well-formed under $[[GG1]]$. This
semantic definition makes it hard to prove metatheory formally, especially when
advanced features are involved.

The Dunfield-Krishnaswami type system (DK) \citep{DK} also uses ordered contexts
as the input and output of the type
inference algorithm for a higher-rank polymorphic type system (\Cref{sec:DK}).
Unlike \cite{gundry2010type}, DK does it in a more syntactic way. In their type system,
instantiation rules decompose type constructs so that unification between
existential variables can only happen between single variables, which can then
be solved by setting the one that appears later to the one that appears earlier.
This way, the information increase of contexts is modeled as the intuitive and
syntactic definition of \textit{context extension} ($[[GG --> DD]]$), which
allows for inductive reasoning and proofs. This approach is adopted in \gpc
(\Cref{chap:Gradual}), so let us consider how DK works in terms of the
instantiation rules in \gpc. Specifically, consider the derivation of $[[evar,
evarb]] [[|-G]] [[evar]] [[<~~]] [[evarb -> int ]]$ in \gpc:

\vspace{5pt}
\noindent $[[DD]] = [[evar1, evar2, evar = evar1 -> evar2, evarb]]$
%
\begin{mathpar}
  \footnotesize
  \inferrule*[right=\rref*{gpc-instl-arr}]{
    \inferrule*[lab=\rref*{gpc-instl-reach}]{ }
      {[[DD |-G evarb <~~ evar1 -| DD[evarb = evar1] ]]}
    \qquad
    \inferrule*[lab=\rref*{gpc-instr-solve}]{
    }{[[DD[evarb = evar1] |-G evar2 <~~ int -| DD[evar2=int][evarb=evar1] ]]}
  }{
    [[evar, evarb |-G evar <~~ evarb -> int -| DD[evar2=int][evarb = evar1]  ]]
  }
\end{mathpar}

\noindent By \rref{gpc-instl-arr}, the variable $[[evar]]$ is solved by an arrow
type $[[evar1 -> evar2]]$ consisting of two fresh existential variables. The two
variables $[[evar1]]$ and $[[evar2]]$ are then instantiated with $[[evarb]]$ and
$[[int]]$, respectively. By \rref{gpc-instl-reach}, the variable $[[evarb]]$ is
solved by $[[evar1]]$, as $[[evar1]]$ appears in the context before $[[evarb]]$,
or otherwise we need to apply \rref{gpc-instr-reach} to set $[[evar1]]$ to
$[[evarb]]$ instead. The final solution context is $[[DD[evar2=int][evarb =
evar1] = evar1, evar2=int, evar=evar1->evar2, evarb=evar1 ]]$.

\paragraph{Challenges.}

However, while the approach of decomposing type constructs works perfectly for DK
and \gpc, it has two drawbacks. First, it produces
duplication: in order to deal with both cases, the instantiation rules are
duplicated
for when the existential variable
appears on the left ($ [[ GG |-G evar <~~ aA -| DD ]] $ in
\Cref{fig:gradual:algo:instantiate}), and when it appears on the right
($ [[ GG |-G aA <~~ evar -| DD ]] $ in \Cref{fig:gradual:algo:instantiate}). For
example, \rref{gpc-instl-arr} has its symmetric counterpart \rref{gpc-instr-arr}:

\begin{mathpar}
  \drule{gpc-instl-arr} \\
  \drule{gpc-instr-arr}
\end{mathpar}

\noindent Worse, this kind of ``duplication'' would scale up with the number of
type constructs in the system.

Second, while decomposition works for function types, it may not work easily for
more complicated types, e.g., dependent types. For example, consider that under
the context $[[evar, evarb]]$, we want to instantiate $[[evar]]$ with a
dependent type $\Pi [[a]]: [[evarb]]. [[a]]$. Here because $[[evarb]]$ appears
after $[[evar]]$, we cannot directly set $[[evar]] = \Pi [[a]] :
[[evarb]].[[a]]$, which is ill-typed. However, if we try to decompose the type
$\Pi [[a]]: [[evarb]]. [[a]]$ like in \rref{gpc-instl-arr}, in which case we
have $[[evar]] = \Pi [[a]]: [[evara1]]. [[evara2]]$, it is obvious that
$[[evar2]]$ should be solved by $[[a]]$. Then, in order to make the solution
well typed, we need to put $[[a]]$ in the front of $[[evar2]]$ in the context.
However, this means that $[[a]]$ would remain in the context, and it would be
available for any later existential variables that should not have access to
$[[a]]$.


\subsection{Our Approach: Type Promotion}

We propose the \textit{promotion} process, which helps resolve the dependency
between existential variables. Promotion combines the advantages of
\cite{gundry2010type} and DK: it is a simple and predictable process, so that
information increase can still be modeled as the syntactic context extension;
moreover, it does not cause any duplication.

To understand how promotion works, let us consider again the example $[[ evar,
evarb]] [[|-G]] [[evar]] [[<~~]] [[evarb -> int]]$. The problem here is that
$[[evarb]]$ is out of the scope of $[[evar]]$ so we cannot directly set $[[evar
= evarb -> int ]]$. Therefore, we first \textit{promote} the type $[[evarb ->
int]]$. At a high level, the promotion process looks for free existential
variables in the type, and solves those out-of-scope existential
variables with fresh ones added to the front of $[[evar]]$,
such that existential variables in the promoted type are all in the scope of
$[[evar]]$. In this case, we will solve $[[evarb]]$ with a fresh variable
$[[evar1]]$, producing the context $[[ evar1, evar, evarb = evar1 ]]$. Notice
that $[[evar1]]$ is inserted right before $[[evar]]$. Now the instantiation
example becomes $[[ evar1, evar, evarb = evar1]] [[|-G]] [[evar]] [[<~~]]
[[evar1 -> int]]$, and $[[evar1 -> int]]$ is a valid solution for $[[evar]]$.
Therefore, we get a final solution context $[[ evar1, evar = evar1 -> int, evarb
= evar1]]$. Comparing the result with the solution context we get from DK
($[[evar1,evar2=int,evar=evar1->evar2, evarb=evar1]]$), it is obvious that these
two solutions are equivalent up to substitution.

\paragraph{Interpretation of Promotion.}

The approach taken by \cite{gundry2010type} and the approach used by DK are
based on the same observation: \textit{the relative order between existential
  variables does not matter for solving a constraint}. The promotion process
captures precisely this observation. Its task is to ``move'' existential
variables to suitable positions \textit{indirectly}, by solving those
out-of-scope existential variables with fresh in-scope ones.

This seems to go against the design principle that the contexts are ordered.
However, ordering is still important for variables whose order matters. For
instance, for polymorphic types, the order between existential variables
$[[evar]]$ and type variables $[[a]]$ is important, so we cannot set $[[evar]]$
to $[[a]]$ under the context $[[(evar, a)]]$ as $[[a]]$ is not in the scope of
$[[evar]]$. Moreover, ordering prevents invalid cyclic contexts, e.g., $[[evara
= evarb -> int]], [[evarb = evara -> int]]$.




\paragraph{Unification for the Simply Typed Lambda Calculus.}

As a first illustration of the promotion process,
\Cref{sec:pr:unif} recasts the unification process for the simply typed lambda
calculus (STLC) using the promotion process. This system illustrates the key
idea of promotion.

\subsection{Polymorphic Promotion}

Instead of unification, the instantiation relation in DK actually deals with the
polymorphic subtyping relation between existential variables and other types.
The promotion process we described above only works for unification. In this
section, we discuss promotion for polymorphic subtyping.

The difficulty of subtyping is that it needs to take unification into account at
the same time. For example, given that $[[evar]]$ is a subtype of $[[int]]$, the
only possible solution is $[[evar = int]]$. Now consider $[[evar]] [[|-]]
[[\/a.a -> a]] [[<:]] [[evar]]$. How can we promote the polymorphic type $[[\/a.a->a]]$ into a
monotype which can serve as a valid solution for $[[evar]]$? One possible answer
is to set $[[evar = int -> int]]$, or $[[evar]] = [[bool -> bool]]$. In fact,
the most general solution for this subtyping problem is $[[evar = evarb ->
evarb]]$ with fresh $[[evarb]]$. Namely, we remove the universal quantifier in
$[[\/a.a->a]]$ and replace the variable $[[a]]$ with a fresh existential
variable $[[evarb]]$ added to the front of $[[evar]]$, resulting in the solution context
$[[evarb, evara = evarb -> evarb]]$.

On the other hand, how can we promote the type $[[\/a.a -> a]]$ in $[[evar]]
[[|-]] [[evar]] [[<:]] [[\/a.a -> a]]$? It turns out that this subtyping is
actually unsolvable, as there is no monotype that can be a subtype of $[[\/a. a
-> a]]$. Therefore, in this case, promoting $[[\/a.a ->a]]$ will
directly add the type variable $[[a]]$ to the tail of the context to promote
$[[a->a]]$. Since $[[a]]$ is added to the tail, it means that $[[a]]$ is out of
the scope of $[[evar]]$ and promoting $[[a->a]]$ would fail, which is exactly
what we want. In fact, the promotion would succeed only if the universally
quantified variable is not
used in the body of the polymorphic type. For example, $[[\/a.int -> int]]$ can
be promoted to $[[int -> int]]$, which is a valid solution for $[[evar]]$ in
$[[evar]] [[|-]] [[evar]] <: [[\/a. int -> int]]$.

From these observations, we extend promotion to \textit{polymorphic promotion},
which is able to resolve the polymorphic subtyping relation for existential
variables. Depending on whether the existential variable appears on the right or
left, polymorphic promotion has two modes, which we call the
\textit{contravariant mode} and the \textit{covariant mode} respectively.

The contravariant mode promotes types as $[[\/a.a ->a]]$ in the case of
$[[evar]] [[|-]] [[\/a.a -> a]] [[<:]] [[evar]]$, where the universal quantifier
is removed and the type variable $[[a]]$ is replaced by a fresh existential
variable added to front of the existential variable being solved. This
corresponds to \rref{gpc-instr-forallL}, except that with promotion, the new
existential variable $[[evarb]]$ (in \rref{gpc-instr-forallL}) will be added
directly before $[[evar]]$ and there is no need to create a marker or to discard
the context after $[[evarb]]$ anymore.

The covariant mode promotes types as $[[\/a. a->a]]$ in the case of $[[evar]]
[[|-]] [[evar]] [[<:]] [[\/a. a -> a]]$. In this case, promoting $[[\/a. a ->
a]]$ will directly add the type variable $[[a]]$ to the tail of the context,
which corresponds to \rref{gpc-instl-forallR}. Since the type variable is out of
the scope of the existential variable being solved, and promotion will succeed
only if the variable is not used in the body of the polymorphic type.

While promoting polymorphic types behaves differently according to the mode, the
mode does not matter for monotypes, as in both $[[evar]] [[<:]] [[int]]$ and
$[[int]] [[<:]] [[evar]]$, $[[evar = int]]$ would be the only solution. Since
function types are contravariant in codomains and covariant in domains,
promoting a function type under a certain mode proceeds to promote its codomain
under the other mode and promote its domain under the original mode. For
example, $[[ evar = (evarb -> evarb) -> (int -> int) ]]$ is a solution for
$[[evar]] [[|-]] [[evar]] [[<:]] [[(\/a.a ->a) -> (\/a. int -> int)]] $, where
$[[(\/a.a ->a) -> (\/a. int -> int)]]$ is promoted under the covariant mode,
which means $[[ \/a.a -> a ]]$ is promoted under the \textit{contravariant} mode
and $[[\/a. int -> int]]$ is promoted under the original covariant mode.




\paragraph{Polymorphic Promotion for Subtyping.}

We illustrate polymorphic promotion by showing that the original instantiation
relationship in DK can be replaced by our polymorphic promotion process.
Furthermore, we show that subtyping, which was built upon instantiation but now
uses polymorphic promotion, remains sound and complete.






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../../Thesis.bib"
%%% End: