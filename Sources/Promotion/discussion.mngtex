\section{Discussion}
\label{sec:pr:discussion}

This section discusses two extensions of promotion, and we can see that
promotion scales naturally to other type features. The first extension explores
dependent types, while the second extension considers gradual types.

\subsection{Promoting Dependent Types}

In \Cref{sec:pr:background} we mentioned the drawback of decomposing type
constructs that it cannot be easily applied to more advanced types like
dependent types. In this section, we discuss how we can apply promotion to
dependent types.

Consider \rref{pr-pi} given below that promotes a dependent type
$[[Pi a:at1.at2]]$.
%
\begin{mathpar}
  \inferrule*[lab=pr-pi]{
    [[ GG |-pr (evar) at1 ~~> at3 -| TT  ]]
    \quad
    [[ TT, a |-pr (evar) [TT]at2 ~~> at4 -| DD, a ]]
  }{
    [[GG |-pr (evar) Pi a : at1. at2 -> int ~~> Pi a : at3. at4 -| DD ]]
  }
\end{mathpar}

\noindent
Here we first promote $[[at1]]$, returning $[[at3]]$. Then we add $[[a]]$ into
the context to promote $[[at2]]$. Finally, we return $[[Pi a:at3. at4]]$ and
discard $[[a]]$ in the output context.

Unfortunately, this design does not work. In particular, consider promoting
$[[Pi a: evarb. a]]$.
%
\begin{mathpar}
  \inferrule*[right=\rref*{pr-pi}]{
    \inferrule*[lab=\rref*{pr-evarL}]{ }{
    [[ evarb, evara |-pr (evar) evarb ~~> evarb -| evarb, evara  ]]}
    \quad
    \inferrule*[lab=\rref*{pr-evarL}]{ }{
    [[ evarb, evara, a]] [[|-pr]]_{[[evar]]} [[a]] [[~~>]] ???}
  }{
    [[evarb, evara]] [[|-pr]]_{[[evar]]} [[Pi a : evarb. a -> int]] [[~~>]]
  }
\end{mathpar}

\noindent
We expect that the promotion would return $[[Pi a:evarb. a]]$. However, after we
add $[[a]]$ into the context to promote $[[a]]$, \rref{pr-tvar} does not apply,
as $[[a]]$ is out of the scope of $[[evar]]$!

The issue can be fixed by changing \rref{pr-tvar} to \rref{pr-tvarr} to not
consider the order of type variables.
%
\begin{mathpar}
  \drule{pr-tvarr}
\end{mathpar}

Then, while promotion resolves the ordering of unification variables, since
there is no constraint for type variables, it is not guaranteed anymore that the
promoted type is well-formed in the prefix context of $[[evar]]$. Therefore, we
need to adjust the rule of subtyping to check explicitly that the result is
well-formed, i.e.,
%
\begin{mathpar}
  \drule{s-instLL}\\
  \drule{s-instRR}
\end{mathpar}

\cite{tfp} include a more detailed discussion and formalization of applying
promotion to a dependently typed lambda calculus.


\subsection{Promoting Gradual Types}

We have shown that polymorphic promotion works for DK. A natural extension is to
also apply polymorphic promotion to \gpc (\Cref{chap:Gradual}). Then the key is
to show how to promote the unknown type. Since comparing with the unknown type
does not impose any constraints, we can simply replace it with a fresh
unification variable:
%
\begin{mathpar}
\drule{p-pr-unknown}
\end{mathpar}

\noindent
For example, we have $[[evar |-pr (evar) int -> unknown ~~> int -> evarb -|
evarb, evar]]$.

For the extended \gpc which restores the dynamic guarantee
(\Cref{chap:Dynamic}), we can replace the unknown type with a fresh gradual
unification variables instead.
%
\begin{mathpar}
\drule{p-pr-unknownG}
\end{mathpar}

With these rules it would be possible to apply polymorphic promotion to \gpc.
Note this discussion is a sketch and we have not fully worked out the full
algorithm yet.

\section{Promotion, Levels, and Generalization}

\subsection{Promotion in Action}

The promotion operation is actually present in the \textit{Glasgow Haskell
  Compiler} (GHC), the state-of-the-art compiler for the Haskell programming
language, though its form is different than what we have presented.

In particular, instead of keeping all the unification variables ordered in the
context, which can be quite inefficient, GHC only keeps them in order with
respect to type variables in the context, by assigning a \textit{level number}
to each unification variable and each type variable, and incrementing the level
number whenever a new type variable is brought into scope. When unifying
$[[evar]] [[~=]] [[t]]$ where $[[evar]]$ is level $N$, to ensure
well-scopedness, GHC checks that all free variables in $[[t]]$ are from level
$N$ or lower, and update levels when needed: if there is a unification variable
$[[evarb]]$ in $[[t2]]$, where $[[evarb]]$ has level $M > N$, then it allocates
$[[evarb1]]$ at level $N$ and set $[[evarb]] = [[evarb1]]$, which essentially
implements the idea of promotion.

As an example, consider during type inference, we need to prove the following
subtyping constraint:
%
\begin{mathpar}
[[empty]] [[|-sub]] [[ \/a. \/ b. a -> b ]]  [[<:]] [[\/c. (\/d. d -> d) -> c]]
\end{mathpar}
%
Let us first work through how promotion works for this example, and then work
through the example again using level numbers.

With promotion, first, we apply \rref{s-forallR} and skolemize $[[c]]$:
% 
\begin{mathpar}
[[c]] [[|-sub]] [[ \/a. \/b. a -> b ]]  [[<:]] [[(\/d. d -> d) -> c]]
\end{mathpar}
% 
Now we apply \rref{s-forallL} twice and instantiate $[[a]]$ and $[[b]]$ with
fresh unification variables:
% 
\begin{mathpar}
[[c, evara, evarb]] [[|-sub]] [[evara -> evarb]]  [[<:]] [[(\/d. d -> d) -> c]]
\end{mathpar}
% 
We then split the function type on both sides (\rref{s-arrow}), and first solve
the contravariant constraint on the argument type:
% 
\begin{mathpar}
[[c, evara, evarb]] [[|-sub]]  [[\/d. d -> d]] [[<:]] [[evara]]
\end{mathpar}
%
We apply \rref{s-forallL} and get:
% 
\begin{mathpar}
  [[c, evara, evarb, evarb2]] [[|-sub]]  [[evarb2 -> evarb2]] [[<:]] [[evara]]
\end{mathpar}
% 
At this point, we can promote $[[evarb2 -> evarb2]]$ by creating a new
unification variable $[[evara2]]$ to the left of $[[evar2]]$, and setting
$[[evarb2 = evara2]]$, so we can solve $[[evara = evara2 -> evara2]]$
% 
\begin{mathpar}
[[ c, evara, evarb, evarb2 |-sub  evarb2 -> evarb2 <: evara -| c, evara2, evara = evara2 -> evara2, evarb, evarb2 = evara2]]
\end{mathpar}
% 
Then we go back to the covariant constraint on the return type, and solve
$[[evarb = c]]$, as $[[c]]$ is already to the left of $[[evarb]]$, and we are done:
\begin{mathpar}
[[c, evara2, evara = evara2 -> evara2, evarb, evarb2 = evara2 |-sub evarb  <: c
  -| c, evara2, evara = evara2 -> evara2, evarb = c, evarb2 = evara2 ]]
\end{mathpar}

Now let us go through the example again with levels\footnote{The process we are
  going to describe is not exactly how GHC works for this example, but it is
  sufficient to illustrate the key idea of levels}. We keep tract of the current
global level, starting from $0$:
%
\begin{mathpar}
  (0) \qquad [[empty]] [[|-sub]] [[ \/a. \/ b. a -> b ]]  [[<:]] [[\/c. (\/d. d -> d) -> c]]
\end{mathpar}
%
Now as before, we skolemise $[[c]]$ on the right, but unlike before, we record
that $[[c]]$ is skolemised at level $0$. Moreover, we increase the global level
number by $1$:
% 
\begin{mathpar}
  (1) \qquad [[c]](0) [[|-sub]] [[ \/a. \/ b. a -> b ]]  [[<:]] [[(\/d. d -> d) -> c]]
\end{mathpar}
% 
We continue by instantiating $[[a]]$ and $[[b]]$ on the left with fresh
unification variables, which are also associated with the current level number. In
this case, we only created new unification variables, so the global level number
stays the same:
% 
\begin{mathpar}
  (1)\qquad [[c]](0), [[evara]] (1), [[evarb]](1) [[|-sub]] [[ evara -> evarb]] [[<:]] [[(\/d. d -> d) -> c]]
\end{mathpar}
%
We split the function types, and the first constraint we get is:
% 
\begin{mathpar}
  (1)\qquad [[c]](0), [[evara]] (1), [[evarb]](1) [[|-sub]] [[\/d. d -> d]]  [[<:]] [[evara ]]
\end{mathpar}
% 
We again instantiate $[[d]]$ with fresh unification variables $[[evarb2]]$.
Since the global level number is still $1$, $[[evarb2]]$ is also at level $[[1]]$:
% 
\begin{mathpar}
  (1)\qquad [[c]](0), [[evara]] (1), [[evarb]](1), [[evarb2]](1) [[|-sub]] [[evarb2 -> evarb2]]  [[<:]] [[evara ]]
\end{mathpar}
% 
Now we want to solve $[[evara]]$ with $[[evarb2 -> evarb2]]$. We check their
level numbers. They are at the same level, so $[[evarb2 -> evarb2]]$ is a valid
solution for $[[evara]]$. We thus get:
% 
\begin{mathpar}
  (1)\qquad [[a]](0), [[evara]] (1), [[evarb]](1), [[evarb2]](1) [[|-sub]] [[evarb2 -> evarb2]]  [[<:]] [[evara ]]
  [[-|]] [[a]](0), [[evara]] (1) = [[evarb2 -> evarb2]], [[evarb]](1), [[evarb2]](1)
\end{mathpar}
% 
Going back to the covariant constraint on the argument types, we get
\begin{mathpar}
  (1)\qquad [[a]](0), [[evara]] (1) = [[evarb2 -> evarb2]], [[evarb]](1), [[evarb2]](1) [[|-sub]] [[evarb2 -> evarb2]]  [[<:]] [[evara ]]
  [[-|]] [[a]](0), [[evara]] (1) = [[evarb2 -> evarb2]], [[evarb]](1), [[evarb2]](1)
\end{mathpar}



\subsection{Levels and Generalization}

It turns out that promotion is closely related to type inference with
\textit{levels}. Levels are first introduced in \citet{remy1992extension} to
implement type inference efficiently, and has been implemented in the OCaml type
checker \cite{ocaml:typechecker}, as well as \textit{Glasgow Haskell Compiler}
(GHC).

Type inference based on levels takes a different than what we have presented. We
take GHC as an example.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../../Thesis.bib"
%%% End: