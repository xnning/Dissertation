\section{Discussion}
\label{sec:pr:discussion}

This section discusses two extensions of promotion, and we can see that
promotion scales naturally to other type features. The first extension explores
dependent types, while the second extension considers gradual types.

\subsection{Promoting Dependent Types}

In \Cref{sec:pr:background} we mentioned the drawback of decomposing type
constructs that it cannot be easily applied to more advanced types like
dependent types. In this section, we discuss how we can apply promotion to
dependent types.

Consider \rref{pr-pi} given below that promotes a dependent type
$[[Pi a:at1.at2]]$.
%
\begin{mathpar}
  \inferrule*[lab=pr-pi]{
    [[ GG |-pr (evar) at1 ~~> at3 -| TT  ]]
    \quad
    [[ TT, a |-pr (evar) [TT]at2 ~~> at4 -| DD, a ]]
  }{
    [[GG |-pr (evar) Pi a : at1. at2 -> int ~~> Pi a : at3. at4 -| DD ]]
  }
\end{mathpar}

\noindent
Here we first promote $[[at1]]$, returning $[[at3]]$. Then we add $[[a]]$ into
the context to promote $[[at2]]$. Finally, we return $[[Pi a:at3. at4]]$ and
discard $[[a]]$ in the output context.

Unfortunately, this design does not work. In particular, consider promoting
$[[Pi a: evarb. a]]$.
%
\begin{mathpar}
  \inferrule*[right=\rref*{pr-pi}]{
    \inferrule*[lab=\rref*{pr-evarL}]{ }{
    [[ evarb, evara |-pr (evar) evarb ~~> evarb -| evarb, evara  ]]}
    \quad
    \inferrule*[lab=\rref*{pr-evarL}]{ }{
    [[ evarb, evara, a]] [[|-pr]]_{[[evar]]} [[a]] [[~~>]] ???}
  }{
    [[evarb, evara]] [[|-pr]]_{[[evar]]} [[Pi a : evarb. a -> int]] [[~~>]]
  }
\end{mathpar}

\noindent
We expect that the promotion would return $[[Pi a:evarb. a]]$. However, after we
add $[[a]]$ into the context to promote $[[a]]$, \rref{pr-tvar} does not apply,
as $[[a]]$ is out of the scope of $[[evar]]$!

The issue can be fixed by changing \rref{pr-tvar} to \rref{pr-tvarr} to not
consider the order of type variables.
%
\begin{mathpar}
  \drule{pr-tvarr}
\end{mathpar}

Then, while promotion resolves the ordering of unification variables, since
there is no constraint for type variables, it is not guaranteed anymore that the
promoted type is well-formed in the prefix context of $[[evar]]$. Therefore, we
need to adjust the rule of subtyping to check explicitly that the result is
well-formed, i.e.,
%
\begin{mathpar}
  \drule{s-instLL}\\
  \drule{s-instRR}
\end{mathpar}

\cite{tfp} include a more detailed discussion and formalization of applying
promotion to a dependently typed lambda calculus.


\subsection{Promoting Gradual Types}

We have shown that polymorphic promotion works for DK. A natural extension is to
also apply polymorphic promotion to \gpc (\Cref{chap:Gradual}). Then the key is
to show how to promote the unknown type. Since comparing with the unknown type
does not impose any constraints, we can simply replace it with a fresh
unification variable:
%
\begin{mathpar}
\drule{p-pr-unknown}
\end{mathpar}

\noindent
For example, we have $[[evar |-pr (evar) int -> unknown ~~> int -> evarb -|
evarb, evar]]$.

For the extended \gpc which restores the dynamic guarantee
(\Cref{chap:Dynamic}), we can replace the unknown type with a fresh gradual
unification variables instead.
%
\begin{mathpar}
\drule{p-pr-unknownG}
\end{mathpar}

With these rules it would be possible to apply polymorphic promotion to \gpc.
Note this discussion is a sketch and we have not fully worked out the full
algorithm yet.

\section{Promotion, Levels, and Generalization}

\subsection{Promotion in Action}

The promotion operation is actually present in the \textit{Glasgow Haskell
  Compiler} (GHC), the state-of-the-art compiler for the Haskell programming
language, though its form is different than what we have presented.

In particular, instead of keeping all the unification variables ordered in the
context, which can be quite inefficient, GHC only keeps them in order with
respect to type variables in the context, by assigning a \textit{level number}
to each unification variable and each type variable, and incrementing the level
number whenever a new type variable is brought into scope. When unifying
$[[evar]] [[~=]] [[t]]$ where $[[evar]]$ is level $N$, to ensure
well-scopedness, GHC checks that all free variables in $[[t]]$ are from level
$N$ or lower, and update levels when needed: if there is a unification variable
$[[evarb]]$ in $[[t2]]$, where $[[evarb]]$ has level $M > N$, then it allocates
$[[evarb1]]$ at level $N$ and set $[[evarb]] = [[evarb1]]$, which essentially
implements the idea of promotion.

As an example, consider during type inference, we need to prove the following
subtyping constraint:
%
\begin{mathpar}
[[empty]] [[|-sub]] [[ \/a. int -> a -> \/b. b ]]  [[<:]] [[int -> \/c. (\/d. d -> d) -> c]]
\end{mathpar}

Below, we work through the example using promotion on the left, and then work
through the example again using level numbers on the right\footnote{The process
  we are going to describe is not exactly how GHC works for this example, but it
  is sufficient to illustrate the key idea of levels.}. The reader is encouraged
to read the left part first before moving to the right.

% ----------------------------------------------------------------------------
\begin{minipage}[t]{0.48\textwidth}
With promotion,
we start with
%
\begin{mathpar}
  [[empty]] [[|-sub]] [[ \/a. int -> a -> \/b. b ]]  [[<:]] [[int -> \/c. (\/d. d -> d) -> c]]
\end{mathpar}
\end{minipage}
%
\begin{minipage}[t]{0.48\textwidth}
  Now let us go through the example again with levels. We keep track of the current
  global level, starting from $0$:
  % 
  \begin{mathpar}
    (0) \quad [[empty]] [[|-sub]] [[ \/a. int -> a -> \/b. b ]]  [[<:]] [[int -> \/c. (\/d. d -> d) -> c]]
  \end{mathpar}
\end{minipage}
 
% ----------------------------------------------------------------------------
\begin{minipage}[t]{0.46\textwidth}
First, we apply \rref{s-forallL} and instantiate $[[a]]$ with $[[evara]]$:
\begin{mathpar}
  [[evara]] [[|-sub]] [[int -> evara -> \/b. b]]  [[<:]] [[int -> \/c. (\/d. d -> d) -> c]]
\end{mathpar}
\end{minipage}
%
\begin{minipage}[t]{0.8\textwidth}%
\end{minipage}
\begin{minipage}[t]{0.46\textwidth}
Now as before, we first instantiating $[[a]]$ with fresh unification variables
$[[evara]]$, but unlike before, we record that $[[evara]]$ in created at level
$0$. In this case, we only created new unification variables, so the global
level number stays the same:
% 
\begin{mathpar}
  (0) \quad  [[evara]] (0) [[|-sub]] [[int -> evara -> \/b. b]]  [[<:]] [[int -> \/c. (\/d. d -> d) -> c]]
\end{mathpar}
\end{minipage}

% ----------------------------------------------------------------------------
\begin{minipage}[t]{0.46\textwidth}
We then apply \rref{s-arrow} and split the constraint into two constraints. As
the contravariant constraint on arguments is simply $[[int <: int]]$, we
continue with the covariant constraint on the return type:
%
\begin{mathpar}
[[evara]] [[|-sub]] [[evara -> \/b. b]]  [[<:]] [[\/c. (\/d. d -> d) -> c]]
\end{mathpar}
\end{minipage}
%
\begin{minipage}[t]{0.8\textwidth}%
\end{minipage}
\begin{minipage}[t]{0.46\textwidth}
  We continue by spitting the arrow types. Again because the argument is simply
  $[[int <: int]]$, we proceed by solving the return type:
  \begin{mathpar}
    (0) \quad [[evara]](0) [[|-sub]] [[evara -> \/b. b]]  [[<:]] [[\/c. (\/d. d -> d) -> c]]
  \end{mathpar}
\end{minipage}
 
% ----------------------------------------------------------------------------
\begin{minipage}[t]{0.46\textwidth}
  We apply \rref{s-forallR} and skolemise $[[c]]$:
  \begin{mathpar}
    [[evara]], [[c]] [[|-sub]] [[evara -> \/b. b]]  [[<:]] [[(\/d. d -> d) -> c]]
  \end{mathpar}
\end{minipage}
%
\begin{minipage}[t]{0.8\textwidth}%
\end{minipage}
\begin{minipage}[t]{0.46\textwidth}
  We now skolemise $[[c]]$ on the right, and also remember that $[[c]]$ is
  skolemised at level $0$. Moreover, since we created a new type variable, we increase the global level number by $1$:
  % 
  \begin{mathpar}
    (1) \quad [[evara]](0), [[c]](0) [[|-sub]] [[evara -> \/b. b]]  [[<:]] [[(\/d. d -> d) -> c]]
  \end{mathpar}
\end{minipage}

% ----------------------------------------------------------------------------
\begin{minipage}[t]{0.46\textwidth}
We apply \rref{s-arrow} again, and we first solve the constraint on the argument
  type:
  \begin{mathpar}
    [[evara]], [[c]] [[|-sub]] [[\/d. d -> d]]  [[<:]] [[evara]]
  \end{mathpar}
\end{minipage}
\begin{minipage}[t]{0.8\textwidth}%
\end{minipage}
\begin{minipage}[t]{0.46\textwidth}
We split the function types, and the first constraint we get is:
  % 
  \begin{mathpar}
    (1) \quad [[evara]](0), [[c]](0) [[|-sub]] [[\/d. d -> d]]  [[<:]] [[evara]]
  \end{mathpar}
\end{minipage}

% ----------------------------------------------------------------------------
\begin{minipage}[t]{0.46\textwidth}
where $[[d]]$ is instantiated with $[[evarb]]$:
\begin{mathpar}
  [[evara]], [[c]], [[evarb]] [[|-sub]] [[evarb -> evarb]]  [[<:]] [[evara]]
\end{mathpar}
\end{minipage}
%
\begin{minipage}[t]{0.8\textwidth}%
\end{minipage}
\begin{minipage}[t]{0.46\textwidth}
We again instantiate $[[d]]$ with fresh unification variables $[[evarb]]$.
Since the global level number is $1$, $[[evarb]]$ is at level $1$:
% 
\begin{mathpar}
  (1) \quad  [[evara]](0), [[c]](0), [[evarb]](1) [[|-sub]] [[evarb -> evarb]]  [[<:]] [[evara]]
\end{mathpar}
% 
\end{minipage}

% ----------------------------------------------------------------------------
\begin{minipage}[t]{0.46\textwidth}
  At this point, we want to solve $[[evara]]$ with $[[evarb -> evarb]]$. However,
  $[[evarb]]$ is not in the scope of $[[evara]]$. So we promote $[[evarb]]$ by
  creating a fresh $[[evara2]]$ to the left
  of $[[evara]]$ and setting $[[evarb = evara2]]$. We can
  then solve $[[evara = evara2 -> evara2]]$.
  \begin{mathpar}
    [[evara]], [[c]], [[evarb]] [[|-sub]] [[evarb -> evarb]]  [[<:]] [[evara]]
    [[-|]] [[evara2]], [[evara = evara2 -> evara2]], [[c]], [[evarb=evara2]]
  \end{mathpar}
\end{minipage}
\begin{minipage}[t]{0.8\textwidth}%
\end{minipage}
\begin{minipage}[t]{0.46\textwidth}
  Now we want to solve $[[evara]]$ with $[[evarb -> evarb]]$. We check their
  level numbers. Because $[[evarb]]$ has a level greater than $0$, we
  ``promote'' $[[evarb]]$ by creating a fresh $[[evara2]]$ at level $0$, and
  setting $[[evarb = evara2]]$. But unlike before, since the context is not
  ordered, we can freely put $[[evara2]]$ at the end of the context:
  % 
  \begin{mathpar}
    (1) \quad [[evara]](0), [[c]](0), [[evarb]](1) [[|-sub]] [[evarb -> evarb]]  [[<:]] [[evara]]
    [[-|]] 
    [[evara]] (0) = [[evara2 -> evara2]], [[c]](0), [[evarb]] (1) = [[evara2]], [[evara2]](0)
  \end{mathpar}
\end{minipage}

% ----------------------------------------------------------------------------
\begin{minipage}[t]{0.46\textwidth}
  Going back to the covariant constraint $[[\/d. d -> d <: c]]$ on the left, which
  can be simply solved by instantiating $[[d]]$ with $[[evarb2]]$ and solve
  $[[evarb2 = c]]$:
  \begin{mathpar}
    [[evara2]], [[evara = evara2 -> evara2]], [[c]], [[evarb=evara2]] [[|-sub]]
    [[\/b. b]] [[<:]] [[c]]
    [[-|]]
    [[evara2]], [[evara = evara2 -> evara2]], [[c]], [[evarb=evara2]], [[evarb2 = c]]
  \end{mathpar}
\end{minipage}
\begin{minipage}[t]{0.8\textwidth}%
\end{minipage}
\begin{minipage}[t]{0.46\textwidth}
Going back to the covariant constraint $[[\/d. d -> d <: c]]$ on the left, which
can be simply solved by instantiating $[[d]]$ with $[[evarb2]] (1)$ and solve
$[[evarb2 = c]]$, as $[[c]]$ has a smaller level:
\begin{mathpar}
  (1) \quad 
  [[evara]] (0) = [[evara2 -> evara2]], [[c]](0), [[evarb]] (1) = [[evara2]], [[evara2]](0)
  [[|-sub]]
  [[\/b. b]] [[<:]] [[c]]
  [[-|]]
  [[evara]] (0) = [[evara2 -> evara2]], [[c]](0), [[evarb]] (1) = [[evara2]],
  [[evara2]](0), [[evarb2]](1) = [[c]]
\end{mathpar}
\end{minipage}

A key observation of the example is that just like promotion, using level
numbers capture precisely that \textit{the relative order between unification
  variables does not matter}; but unlike promotion which ensures well-scopedness
using \textit{order}, using level numbers ensures well-scopedness using
\textit{levels}. The advantage with levels is that the whole type context is
unordered, which can be implemented more efficiently in practice. While not
shown in this example, just like promotion can fail to promote the order of
variables in, for example, $[[evara, c]] [[|-sub]] [[evara]] [[<:]] [[c]]$,
promotion can fail to promote levels as in $[[c]](1), [[ evara ]](0) [[|-sub]]
[[evara]] [[<:]] [[c]]$, where even though $[[c]]$ appears before $[[evara]]$ in
the context, it has a level greater than $[[evara]]$.

\subsection{Levels and Generalization}

It turns out that promotion is closely related to type inference with
\textit{levels}. Levels are first introduced in \citet{remy1992extension} to
implement type inference efficiently, and has been implemented in the OCaml type
checker \cite{ocaml:typechecker}, as well as \textit{Glasgow Haskell Compiler}
(GHC).

Type inference based on levels takes a different than what we have presented. We
take GHC as an example.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../../Thesis.bib"
%%% End: