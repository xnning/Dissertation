%include polycode.fmt
%include rae.fmt

%if style == newcode
\begin{code}
{-# LANGUAGE PolyKinds #-}

module Introduction where

import Prelude hiding (Maybe(..))
import Data.Kind ( Type )

\end{code}
%endif


\section{Introduction and Motivation}

\subsection{The Kind Inference Challenge}

Modern functional languages such as Haskell, ML, and OCaml come with powerful
forms of type inference. The global type-inference algorithms employed in those
languages are derived from the Hindley-Milner type system
(HM) \citep{hindley,Damas:Milner}, with multiple extensions. As the languages
evolve, researchers also formalize the key aspects of type inference for the new
extensions. Common extensions of HM include \emph{higher-ranked
  polymorphism} \citep{odersky:putting, practical:inference} and
\emph{type-inference for GADTs} \citep{PeytonJones:gadt}, which have both been
formally studied thoroughly.

Most research work for extensions of HM so far (including OL, DK, \ap and \gpc) has
focused on forms of polymorphism, where type variables all have the same kind.
In these systems, the type variables introduced by universal quantifiers and/or
type declarations all stand for proper types (i.e., they have kind |*|). In such
a simplified setting, datatype declarations such as |data Maybe a = Nothing ||
Just a| pose no problem at all for type inference: with only one possible kind
for |a|, there is nothing to infer.

However, real-world implementations for languages like Haskell support a
non-trivial kind language, including kinds other than |*|. \hne accepts
\emph{higher-kinded polymorphism} \citep{jones1995system}, enabling datatype
declarations such as |data AppInt f = Mk (f Int)|. The type of constructor |Mk|
applies the type variable |f| to an argument |Int|. Accordingly, |AppInt Bool|
would not work, as the type |Bool Int| (in the instantiated type of |Mk|) is
invalid. Instead, we must write something like |AppInt Maybe|: the argument to
|AppInt| must be suitable for applying to |Int|. In \hne, |AppInt| has kind |(*
-> *) -> *|. For \hne-style higher-kinded polymorphism, \citet{jones1995system}
presents one of the few extensions of HM that deals with a non-trivial language
of kinds. His work addresses the related problem of inference for
\emph{constructor type classes}, although he does not show directly how to do
inference for datatype declarations.

Modern Haskell\footnote{We consider the Glasgow Haskell Compiler's
  implementation of Haskell, in version 8.8.} has a much richer type and kind
language compared to \hne. In recent years, Haskell has seen a dramatic surge of
new features that extend the expressive power of algebraic datatypes. Such
features include \emph{GADTs}, \emph{kind polymorphism} \citep{yorgey2012giving}
with \emph{implicit kind arguments}, and \emph{dependent
  kinds} \citep{Weirich:2013:SFE:2500365.2500599}, among others. With great power
comes great responsibility: now we must be able to infer these kinds, too. For
instance, consider these datatype declarations:

\begin{code}
data App f a  = MkApp (f a)
data Fix f    = In (f (Fix f))

data T        =  MkT1 (App Maybe Int) 
              |  MkT2 (App Fix Maybe)  -- accept or reject?
\end{code}

\noindent Should the declaration for |T| be accepted or rejected? In a \hne
setting, the kind of |App| is |(* -> *) -> * -> *|. Therefore |T| should be
rejected, because in |MkT2| the datatype |App| is applied to |Fix :: (* -> *) ->
* | and |Maybe :: * -> *|, which do not match the expected kinds of |App|.
However, with kind polymorphism, |T| is accepted, because |App| has the more
general kind |forall k. (k -> *) -> k -> *|. With this kind, both uses of |App|
in |T| are valid.
  
The questions we ask in this section are these:
\emph{Which datatype declarations should be accepted?}
\emph{What kinds do accepted datatypes have?}
Surprisingly, the literature is essentially silent on these
questions---we are unaware of any formal treatment of kind inference
for datatype declarations.

Inspired by previous research on type inference, we offer declarative
specifications for two languages: \hne, as
standardized \citep{jones2003haskell}~(\Cref{sec:h98}); and \tit, a significant
fragment of modern Haskell~(\Cref{subsec:tit:decl}). These specifications are
complemented with algorithmic versions that can guide implementations
(Sections~\ref{sec:algo} and \ref{sec:tit_algo}). To relate the declarative and
algorithmic formulations we study various properties, including
\emph{soundness}, \emph{completeness}, and the existence of \emph{principal
  kinds} (Sections~\ref{sec:98:context-extension}, \ref{sec:type_par}, and
\ref{subsec:tit:sound-complete}). TODO: fix references.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../../Thesis.bib"
%%% End:

%%  LocalWords:  polycode newcode PolyKinds endif HM AppInt Mk App MkApp MkT
