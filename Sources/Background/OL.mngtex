\section{The Odersky-L{\"a}ufer Type System}
\label{sec:OL}

The HM system is simple, flexible and powerful. Yet, since the type annotations
in lambda abstractions are always missing, HM only derives polymorphic types of
\textit{rank 1}. That is, universal quantifiers only appear at the top level.
Polymorphic types are of \textit{higher-rank}, if universal quantifiers can
appear anywhere in a type.

Essentially higher-rank types enable much of the expressive power of System F,
with the advantage of implicit polymorphism. Complete type inference for System
F is known to be undecidable \citep{F:undecidable}. \cite{odersky:putting}
proposed a type system, hereafter referred to as OL, which extends HM by
allowing lambda abstractions to have explicit \textit{higher-rank} types as type
annotations. As a motivation, consider the following program\footnote{For the
  purpose of illustration, we assume basic constructs like booleans and
  pairs in examples.}:

\begin{lstlisting}
(\f. (f 1, f 'a')) (\x. x)
\end{lstlisting}

\noindent which is not typeable under HM because it fails to infer the type of
\lstinline{f}: \lstinline{F} is supposed to be polymorphic as it is applied to
two arguments of different types. With OL we can add the type annotation for
\lstinline{f}:

\begin{lstlisting}
(\f : foralla. a -> a. (f 1, f 'a')) (\x. x)
\end{lstlisting}

\noindent Note that the first function now has a rank-2 type, as the polymorphic
type \lstinline{foralla. a -> a} appears in the argument position of a function:

\begin{lstlisting}
(\f : foralla. a -> a. (f 1, f 'a')) : (foralla. a -> a) -> (Int, Char)
\end{lstlisting}

In the rest of this section, we first give the definition of the rank of a type,
and then present the declarative specification of OL, and show that OL is a
conservative extension of HM.

\subsection{Higher-rank Types}

We define the rank of types as follows.

\begin{definition}[Type rank]
The \textit{rank} of a type is the depth at which universal quantifiers appear
contravariantly \citep{kfoury:type}. Formally,

\begin{center}
\begin{tabular}{lcl} \toprule
  $\mathsf{rank}([[t]])$        & $=$ & $0$ \\
  $\mathsf{rank}([[A1 -> A2]])$ & $=$ & $\mathsf{max}(\mathsf{rank}([[A1]]) + 1, \mathsf{rank}([[A2]]) )$ \\
  $\mathsf{rank}([[\/ a. A]])$  & $=$ & $\mathsf{max}(1, \mathsf{rank}([[A]]) )$ \\
  \bottomrule
\end{tabular}
\end{center}
\end{definition}

Below we give some examples:

\begin{center}
\begin{tabular}{lcl}
  $\mathsf{rank}([[int -> int]])$  & $=$ & $0$ \\
  $\mathsf{rank}([[\/a. a -> a]])$ & $=$ & $1$ \\
  $\mathsf{rank}([[int -> (\/a. a -> a)]])$ & $=$ & $1$ \\
  $\mathsf{rank}([[(\/a. a -> a) -> int]])$ & $=$ & $2$ \\
\end{tabular}
\end{center}

From the definition, we can see that monotypes always have rank $0$, and the
polymorphic types in HM ($[[A]]$ in \Cref{fig:HM}) has at most rank $1$.



\begin{figure}[t]
    \centering
    \begin{tabular}{lrcl} \toprule
      Expressions & $[[e]]$  & $\Coloneqq$ & $[[x]]  \mid [[n]]  \mid [[\x : A . e]] \mid [[ \x . e ]] \mid [[e1 e2]] \mid [[ let x = e1 in e2  ]] $ \\
      Types       & $[[A]]$  & $\Coloneqq$ & $[[int]] \mid [[a]] \mid [[A1 -> A2]] \mid [[\/ a. A]] $ \\
      Monotypes   & $[[t]]$  & $\Coloneqq$ & $[[int]] \mid [[a]] \mid [[t1 -> t2]] $ \\
      Contexts    & $[[dd]]$ & $\Coloneqq$ & $[[empty]]  \mid [[dd , x : A]]  \mid [[dd, a]] $ \\
      \bottomrule
    \end{tabular}
  \caption{Syntax of the Odersky-L{\"a}ufer type system.}
  \label{fig:OL}
\end{figure}



\subsection{Declarative System}

\paragraph{Syntax.}

The syntax of OL is given in \Cref{fig:OL}. Comparing to HM, we
observe the following differences.

First, expressions $[[e]]$ include not only unannotated lambda abstractions
$[[\x. e]]$, but also annotated lambda abstractions $[[\x : A . e]]$, where the
type annotation $[[A]]$ is a polymorphic type. Thus unlike HM, the argument
type for a function is not limited to a monotype.

Second, the polymorphic types $[[A]]$ now include the integer type $[[int]]$,
type variables $[[a]]$, functions $[[A1 -> A2]]$ and universal quantifications
$[[\/a. A]]$. Since the argument type in a function can be polymorphic, we see
that OL supports \textit{arbitrary} rank of types. The definition of monotypes
remains the same, with polymorphic types still subsuming monotypes.

Finally, in addition to variable types, the contexts $[[dd]]$ now also keep
track of type variables. Note that in the original work in
\cite{odersky:putting}, the system, much like HM, does not track type variables;
instead, it explicitly checks that type variables are fresh with respect to a
context or a type when needed. Here we include type variables in contexts, as it
sets us well for the Dunfield-Krishnaswami type system to be introduced in the
next section. Moreover, it provides a complete view of possible formalisms of
contexts in a type system with generalization. As before, we assume all items in
a context are distinct.

Now since the context tracks type variables, we define the notion of
\textit{well-formedness} of types, given in \Cref{fig:OL:wf}. For a type to be
well-formedness, it must have all its free variable bound in the context. All
rules are straightforward.

\begin{figure}
  \drules[ol-wf]{$ [[dd |-OL A ]] $}{Type Well-formedness}{int, tvar, arrow, forall}
  \caption{Well-formedness of types in the Odersky-L{\"a}ufer type system.}
  \label{fig:OL:wf}
\end{figure}


\begin{figure}
  \drules[ol]{$ [[dd |-OL e : A ]] $}{Typing}{var, int, lamann, lam, app, let, gen, sub}

  \drules[ol-s]{$ [[dd |-OL A1 <: A2 ]] $}{Subtyping}{tvar, int, arrow, forallL, forallR}

  \caption{Static semantics of the Odersky-L{\"a}ufer type system.}
  \label{fig:OL:static}
\end{figure}


\paragraph{Type System.}

The typing rules for OL are given in \Cref{fig:OL:static}.

\Rref{ol-var} and \rref{ol-int} are the same as that of HM. \Rref{ol-lamann}
type-checks annotated lambda abstractions, by simply putting $[[x:A]]$ into the
context to type the body. For unannotated lambda abstractions in \rref{ol-lam},
the system still guesses a mere monotype. That is, the system never guesses a
polymorphic type for lambdas; instead, an explicit polymorphic type annotation
is required. \Rref{ol-app} and \rref{ol-let} are similar as HM, except that
polymorphic types may appear in return types. In the generalization
\rref{ol-gen}, we put a fresh type variable $[[a]]$ into the context, and the
return type $[[A]]$ is then generalized over $[[a]]$, returning $[[\/a. A]]$.

The subsumption \rref{ol-sub} is crucial for OL, which allows an expression of
type $[[A1]]$ to have type $[[A2]]$ with $[[A1]]$ being a subtype of $[[A2]]$
($[[dd |- A1 <: A2]]$). Note that the instantiation \rref{hm-inst} in HM is a
special case of \rref{ol-sub}, as we have $[[\/ </ ai // i /> . t <: t [ </ ai
~> ti // i /> ] ]]$ by applying \rref{hm-s-forallL} repeatedly.

The subtyping relation of OL $[[dd |-OL A1 <: A2]]$ also generalizes the
subtyping relation of HM. In particular, in \rref{ol-s-arrow}, functions are
\textit{contravariant} on arguments, and \textit{covariant} on return types.
This rule allows us to compare higher-rank polymorphic types, rather than just
polymorphic types with universal quantifiers only at the top level. For example,

\begin{center}
  \begin{tabular}{lcl}
    $[[dd |-OL \/a. a -> a]]$  & $[[<:]]$ & $[[int -> int]]$ \\
    $[[dd |-OL int -> (\/a. a -> a)]]$  & $[[<:]]$ & $[[int -> (int -> int)]]$ \\
    $[[dd |-OL (int -> int) -> int]]$  & $[[<:]]$ & $[[(\/a. a -> a) -> int]]$ \\
  \end{tabular}
\end{center}

\paragraph{Predicativity.}

In a system with high-ranker types, one important design decision to make is
whether the system is \textit{predicative} or \textit{impredicative}. A system
is predicative, if the type variable bound by a universal quantifier is only
allowed to be substituted by a monotype; otherwise it is impredicative. It is
well-known that general type inference for impredicativity is
undecidable~\citep{F:undecidable}. OL is predicative, which can be seen from
\rref{ol-s-forallL}. We focus only on predicative type systems throughout the
thesis.

\subsection{Relating to HM}

It can be proved that OL is a conservative extension of HM. That is, every
well-typed expression in HM is well-typed in OL, modulo the different
representation of contexts.

\begin{theorem}[Odersky-L{\"a}ufer type system conservative over Hindley-Milner type system]
  If $[[dd |-HM e : A]]$,
  suppose $[[dd']]$ is $[[dd]]$ extended with type variables in $[[dd]]$ and $[[A]]$,
  then $[[dd' |-OL e : A ]]$.
\end{theorem}

Moreover, since OL is predicative and only guesses monotypes for unannotated
lambda abstractions, its algorithmic system can be implemented as a direct
extension of the one for HM.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../Thesis"
%%% org-ref-default-bibliography: "../Thesis.bib"
%%% End: